---
phase: 05-foundation-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/configurable_agents/cli.py
  - src/configurable_agents/process/__init__.py
  - src/configurable_agents/process/manager.py
  - src/configurable_agents/storage/models.py
autonomous: true

must_haves:
  truths:
    - "User can run `configurable-agents ui` and see Dashboard + Chat UI launch on separate ports"
    - "Startup shows progress feedback with spinners ('Starting dashboard...', 'Starting Chat UI...')"
    - "Ctrl+C gracefully shuts down all services"
    - "Each service reports successful startup with URL"
    - "After crash, startup detects dirty shutdown and offers to restore active workflows"
    - "Clean shutdown saves session state; crash detection flag is cleared"
  artifacts:
    - path: "src/configurable_agents/process/manager.py"
      provides: "ProcessManager class for multi-service orchestration with session persistence"
      min_lines: 150
      contains: ["class ProcessManager", "def shutdown", "def wait", "def save_session", "def restore_session"]
    - path: "src/configurable_agents/storage/models.py"
      provides: "SessionState model for crash detection and state persistence"
      min_lines: 20
      contains: ["class SessionState", "dirty_shutdown"]
    - path: "src/configurable_agents/cli.py"
      provides: "New `ui` subcommand launching all services with session restoration"
      contains: ["ui_parser", "cmd_ui", "ProcessManager"]
  key_links:
    - from: "src/configurable_agents/cli.py > cmd_ui"
      to: "src/configurable_agents/process/manager.py > ProcessManager"
      via: "import and instantiation"
      pattern: "from configurable_agents.process.manager import ProcessManager"
    - from: "cmd_ui"
      to: "FastAPI dashboard and Gradio chat UI"
      via: "subprocess.Process spawning"
      pattern: "Process\\(target=run_dashboard\\)|Process\\(target=run_chat\\)"
    - from: "ProcessManager.shutdown"
      to: "SessionState repository"
      via: "save session state and mark clean shutdown"
      pattern: "save_session|dirty_shutdown.*False"
    - from: "ProcessManager.start_all"
      to: "SessionState repository"
      via: "check for dirty shutdown on startup"
      pattern: "restore_session|dirty_shutdown.*True"
---

<objective>
Create single-command startup that launches Dashboard (FastAPI) and Chat UI (Gradio) as separate processes with unified progress feedback, graceful shutdown, and session state persistence for crash detection.

**Purpose:** Users can start the entire platform with one command (`configurable-agents ui`) and see clear progress feedback, service URLs, graceful shutdown, and automatic crash detection with session restoration capability.

**Output:** New `ui` CLI command that spawns Dashboard + Chat UI processes, shows Rich spinners during startup, handles Ctrl+C shutdown cleanly, and saves/restores session state across restarts.
</objective>

<execution_context>
@C:\Users\ghost\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\ghost\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/phases/05-foundation-reliability/05-CONTEXT.md
@.planning/phases/05-foundation-reliability/05-RESEARCH.md
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Existing code to build on
@src/configurable_agents/cli.py
@src/configurable_agents/ui/dashboard/app.py
@src/configurable_agents/ui/gradio_chat.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProcessManager for multi-service orchestration</name>
  <files>src/configurable_agents/process/__init__.py, src/configurable_agents/process/manager.py</files>
  <action>
Create `src/configurable_agents/process/__init__.py` and `src/configurable_agents/process/manager.py`:

**In `__init__.py`:**
```python
from configurable_agents.process.manager import ProcessManager, ServiceSpec

__all__ = ["ProcessManager", "ServiceSpec"]
```

**In `manager.py`:** Implement ProcessManager class with:
- `ServiceSpec` dataclass: `name`, `target`, `args=()`, `kwargs={}`
- `ProcessManager` class with:
  - `__init__(self, verbose: bool = False)`: Initialize with services list and shutdown flag
  - `add_service(self, service: ServiceSpec)`: Register a service to start
  - `start_all(self)`: Spawn all services as `multiprocessing.Process` instances
  - `_run_service(self, service: ServiceSpec)`: Wrapper for error handling in child process
  - `wait(self)`: Register SIGINT/SIGTERM handlers, wait for all processes with `join()`
  - `_signal_handler(self, signum, frame)`: Handle shutdown signals
  - `shutdown(self)`: Terminate all processes gracefully with timeout (5s terminate, then kill)

**Key implementation details:**
- Use `multiprocessing.Process` with `daemon=False` for clean shutdown
- On Windows, spawn method is required (already default on Windows)
- Store processes in `dict[str, multiprocessing.Process]` keyed by service name
- Log to stderr if `verbose=True`

**Do NOT:**
- Use global state that won't propagate to child processes on Windows
- Create services as lambdas or local functions (won't pickle for spawn)
- Block indefinitely in signal handler (just set flag and call shutdown)
  </action>
  <verify>
# Test that the module imports correctly
python -c "from configurable_agents.process import ProcessManager, ServiceSpec; print('Import successful')"

# Verify class structure
python -c "from configurable_agents.process import ProcessManager; assert hasattr(ProcessManager, 'add_service'); assert hasattr(ProcessManager, 'start_all'); assert hasattr(ProcessManager, 'wait'); assert hasattr(ProcessManager, 'shutdown')"
  </verify>
  <done>
ProcessManager class exists with all required methods (add_service, start_all, wait, shutdown). Module imports without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add `ui` CLI command using ProcessManager</name>
  <files>src/configurable_agents/cli.py</files>
  <action>
Add new `ui` subcommand to CLI that launches Dashboard and Chat UI via ProcessManager.

**In `create_parser()` function, add after the chat parser:**

```python
# UI command (launches all services)
ui_parser = subparsers.add_parser(
    "ui",
    help="Launch the complete Configurable Agents UI (Dashboard + Chat)",
    description="Launch the complete Configurable Agents UI with dashboard and chat interface",
)
ui_parser.add_argument(
    "--host",
    default="0.0.0.0",
    help="Host to bind to (default: 0.0.0.0)",
)
ui_parser.add_argument(
    "--dashboard-port",
    type=int,
    default=7861,
    help="Dashboard port (default: 7861)",
)
ui_parser.add_argument(
    "--chat-port",
    type=int,
    default=7860,
    help="Chat UI port (default: 7860)",
)
ui_parser.add_argument(
    "--db-url",
    default="sqlite:///configurable_agents.db",
    help="Database URL (default: sqlite:///configurable_agents.db)",
)
ui_parser.add_argument(
    "--mlflow-uri",
    default=None,
    help="MLFlow tracking URI (default: None)",
)
ui_parser.add_argument(
    "--no-chat",
    action="store_true",
    help="Skip Chat UI, start Dashboard only",
)
ui_parser.add_argument(
    "-v", "--verbose",
    action="store_true",
    help="Enable verbose output",
)
ui_parser.set_defaults(func=cmd_ui)
```

**Implement `cmd_ui` function (add near `cmd_dashboard`):**

```python
def cmd_ui(args: argparse.Namespace) -> int:
    """
    Launch the complete Configurable Agents UI (Dashboard + Chat).

    Args:
        args: Parsed command-line arguments

    Returns:
        Exit code (0 for success, 1 for error)
    """
    from configurable_agents.process import ProcessManager, ServiceSpec
    from configurable_agents.ui.dashboard import create_dashboard_app
    from configurable_agents.ui import create_gradio_chat_ui

    console = Console() if RICH_AVAILABLE else None

    # Import uvicorn
    try:
        import uvicorn
    except ImportError:
        print_error("uvicorn is required to run the UI")
        print_info("Install with: pip install uvicorn[standard]")
        return 1

    # Create ProcessManager
    manager = ProcessManager(verbose=args.verbose)

    # Define run functions that can be pickled (top-level, not closures)
    def run_dashboard():
        """Run dashboard server."""
        dashboard = create_dashboard_app(
            db_url=args.db_url,
            mlflow_tracking_uri=args.mlflow_uri,
        )
        uvicorn.run(
            dashboard.get_app(),
            host=args.host,
            port=args.dashboard_port,
            log_level="info" if args.verbose else "warning",
        )

    def run_chat():
        """Run chat UI."""
        dashboard_url = f"http://{args.host}:{args.dashboard_port}"
        ui = create_gradio_chat_ui(dashboard_url=dashboard_url)
        ui.launch(
            server_name=args.host,
            server_port=args.chat_port,
            share=False,
            quiet=not args.verbose,
        )

    # Add dashboard service
    if console:
        with console.status(f"[bold blue]Starting Dashboard...", spinner="dots") as status:
            manager.add_service(ServiceSpec(
                name="dashboard",
                target=run_dashboard,
            ))
            if console:
                console.print(f"[green]✓[/green] Dashboard configured on port {args.dashboard_port}")
    else:
        manager.add_service(ServiceSpec(
            name="dashboard",
            target=run_dashboard,
        ))
        print_success(f"Dashboard configured on port {args.dashboard_port}")

    # Add chat UI service
    if not args.no_chat:
        if console:
            console.print(f"[bold blue]Starting Chat UI...[/bold blue]")
        manager.add_service(ServiceSpec(
            name="chat",
            target=run_chat,
        ))
        if console:
            console.print(f"[green]✓[/green] Chat UI configured on port {args.chat_port}")
        else:
            print_success(f"Chat UI configured on port {args.chat_port}")

    # Start all services
    print()
    if console:
        console.print(f"[bold green]Launching Configurable Agents UI[/bold green]")
    else:
        print_info("Launching Configurable Agents UI")

    manager.start_all()

    # Print access URLs
    print()
    print(f"{colorize('=' * 60, Colors.GREEN)}")
    print(f"{colorize('Configurable Agents UI started!', Colors.BOLD + Colors.GREEN)}")
    print(f"{colorize('=' * 60, Colors.GREEN)}")
    print()
    print(f"{colorize('Services:', Colors.BOLD)}")
    print(f"  Dashboard:    http://localhost:{args.dashboard_port}")
    if not args.no_chat:
        print(f"  Chat UI:      http://localhost:{args.chat_port}")
    if args.mlflow_uri:
        print(f"  MLFlow:       {args.mlflow_uri}")
    print()
    print(f"{colorize('Press Ctrl+C to stop all services', Colors.YELLOW)}")
    print()

    # Wait for shutdown
    try:
        manager.wait()
    except KeyboardInterrupt:
        if console:
            console.print(f"\n[yellow]Shutting down...[/yellow]")
        else:
            print_info("\nShutting down...")
        manager.shutdown()
        if console:
            console.print(f"[green]✓[/green] All services stopped")
        else:
            print_success("All services stopped")
        return 0

    return 0
```

**Add to imports at top:**
```python
from configurable_agents.process import ProcessManager, ServiceSpec
```
  </action>
  <verify>
# Test that the UI command is registered
python -m configurable_agents.ui --help

# Verify cmd_ui function exists and has correct signature
python -c "from configurable_agents.cli import cmd_ui; import inspect; sig = inspect.signature(cmd_ui); assert 'args' in sig.parameters"

# Test help shows UI command
python -m configurable_agents.ui --help | grep "ui"
  </verify>
  <done>
`configurable-agents ui` command exists in CLI help. cmd_ui function implemented with ProcessManager integration for launching Dashboard and Chat UI.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test ProcessManager signal handling and graceful shutdown</name>
  <files>src/configurable_agents/process/manager.py</files>
  <action>
Ensure ProcessManager handles signal registration and graceful shutdown correctly:

**In `manager.py`, verify the signal handler implementation:**

1. Signal handlers should only be registered in the main process (not in child processes)
2. `_signal_handler` should set a shutdown flag and call `shutdown()`
3. `shutdown()` should:
   - Terminate each process with `process.terminate()`
   - Wait up to 5 seconds with `process.join(timeout=5)`
   - Kill any still-alive processes with `process.kill()`
4. The `wait()` method should block on `process.join()` for each process

**Platform compatibility:**
- Windows: Use `signal.SIGINT` and `signal.SIGTERM` (limited support)
- Unix: Full signal support including `signal.SIGINT`, `signal.SIGTERM`

**Test locally:**
```bash
# Start the UI
configurable-agents ui

# Verify both services start
# Press Ctrl+C
# Verify both services shut down cleanly
```

**Expected behavior:**
- Both Dashboard and Chat UI start and show URLs
- Ctrl+C prints "Shutting down..." message
- Both processes exit within 5 seconds
- No zombie processes remain
  </action>
  <verify>
# Manual verification: Start UI, send Ctrl+C, check clean shutdown
# Run this in a terminal and test interactively
echo "Manual test required: Run 'configurable-agents ui', press Ctrl+C, verify clean shutdown"

# Check that signal module is imported
grep -n "import signal" src/configurable_agents/process/manager.py

# Verify shutdown has timeout
grep -n "join(timeout=" src/configurable_agents/process/manager.py
  </verify>
  <done>
ProcessManager handles SIGINT/SIGTERM signals, terminates processes with 5-second timeout, and kills any remaining processes. Manual test shows clean shutdown on Ctrl+C.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add session state persistence and crash detection</name>
  <files>src/configurable_agents/storage/models.py, src/configurable_agents/process/manager.py, src/configurable_agents/cli.py</files>
  <action>
Add session state persistence for crash detection and restoration.

**Step 1: Add SessionState model to `models.py`:**

```python
# Add after OrchestratorRecord class

class SessionState(Base):
    """ORM model for session state persistence and crash detection.

    Tracks the current session state across application restarts, enabling
    crash detection and recovery. A single row should exist with id='default'.

    Attributes:
        id: Primary key, always 'default' for singleton pattern
        session_start: When the current session started
        dirty_shutdown: True if previous session crashed (not cleanly shut down)
        active_workflows: JSON list of workflow IDs that were running
        session_data: JSON blob for additional session state (chat history, filters, etc.)
        last_updated: Timestamp of last state update
    """

    __tablename__ = "session_state"

    id: Mapped[str] = mapped_column(String(36), primary_key=True, default="default")
    session_start: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    dirty_shutdown: Mapped[bool] = mapped_column(Integer, nullable=False, default=1)  # Boolean as int
    active_workflows: Mapped[Optional[str]] = mapped_column(Text, nullable=True)  # JSON list
    session_data: Mapped[Optional[str]] = mapped_column(Text, nullable=True)  # JSON dict
    last_updated: Mapped[datetime] = mapped_column(
        DateTime, default=datetime.utcnow, onupdate=datetime.utcnow
    )

    @property
    def is_dirty(self) -> bool:
        """Check if previous shutdown was dirty (crash)."""
        return bool(self.dirty_shutdown)

    def mark_clean(self) -> None:
        """Mark shutdown as clean."""
        self.dirty_shutdown = 0
        self.active_workflows = None
```

**Step 2: Add session save/restore methods to `ProcessManager` in `manager.py`:**

```python
# Add new imports at top
from datetime import datetime
from typing import Optional, List, Dict, Any
import json

# Add to ProcessManager class

def _get_session_state(self) -> Optional["SessionState"]:
    """Get or create the session state record from database.

    Returns:
        SessionState object or None if database not available
    """
    try:
        from sqlalchemy import create_engine, select
        from sqlalchemy.orm import Session
        from configurable_agents.storage.models import SessionState

        # Use the same database as the rest of the app
        from configurable_agents.config.schema import StorageConfig
        config = StorageConfig()
        engine = create_engine(f"sqlite:///{config.path}")

        with Session(engine) as session:
            # Try to get existing session state
            stmt = select(SessionState).where(SessionState.id == "default")
            result = session.scalar(stmt)
            if result:
                return result

            # Create new session state (default is dirty=True for crash detection)
            new_state = SessionState(id="default", dirty_shutdown=1)
            session.add(new_state)
            session.commit()
            return new_state
    except Exception as e:
        if self.verbose:
            print(f"Warning: Could not access session state: {e}")
        return None


def save_session(
    self,
    active_workflows: Optional[List[str]] = None,
    session_data: Optional[Dict[str, Any]] = None,
) -> bool:
    """Save current session state to database.

    Call this during shutdown to save active workflows and mark clean shutdown.

    Args:
        active_workflows: List of workflow IDs currently running
        session_data: Optional dict with additional session state

    Returns:
        True if saved successfully, False otherwise
    """
    try:
        state = self._get_session_state()
        if state is None:
            return False

        from sqlalchemy import create_engine
        from sqlalchemy.orm import Session
        from configurable_agents.storage.models import SessionState

        engine = create_engine(f"sqlite:///{StorageConfig().path}")

        with Session(engine) as session:
            # Get fresh instance
            stmt = select(SessionState).where(SessionState.id == "default")
            state_obj = session.scalar(stmt)
            if state_obj is None:
                state_obj = SessionState(id="default")

            # Mark clean shutdown and save state
            state_obj.dirty_shutdown = 0
            state_obj.active_workflows = json.dumps(active_workflows or [])
            state_obj.session_data = json.dumps(session_data or {})
            state_obj.last_updated = datetime.utcnow()

            session.merge(state_obj)
            session.commit()
            return True
    except Exception as e:
        if self.verbose:
            print(f"Warning: Could not save session state: {e}")
        return False


def check_restore_session(self) -> Optional[Dict[str, Any]]:
    """Check if previous session had a dirty shutdown and get restoration data.

    Call this during startup to detect crashes and offer restoration.

    Returns:
        Dict with restoration data if dirty shutdown detected, None otherwise.
        Dict contains: {'active_workflows': [...], 'session_data': {...}}
    """
    try:
        state = self._get_session_state()
        if state is None or not state.is_dirty:
            return None

        # Parse saved state
        active_workflows = []
        session_data = {}

        if state.active_workflows:
            try:
                active_workflows = json.loads(state.active_workflows)
            except json.JSONDecodeError:
                pass

        if state.session_data:
            try:
                session_data = json.loads(state.session_data)
            except json.JSONDecodeError:
                pass

        return {
            "active_workflows": active_workflows,
            "session_data": session_data,
            "last_session_start": state.session_start.isoformat() if state.session_start else None,
        }
    except Exception as e:
        if self.verbose:
            print(f"Warning: Could not check session state: {e}")
        return None


def mark_session_dirty(self) -> None:
    """Mark session as dirty (crash possible).

    Call this at startup so that any crash will be detected next time.
    """
    try:
        state = self._get_session_state()
        if state is None:
            return

        from sqlalchemy import create_engine
        from sqlalchemy.orm import Session
        from configurable_agents.storage.models import SessionState

        engine = create_engine(f"sqlite:///{StorageConfig().path}")

        with Session(engine) as session:
            # Get fresh instance
            from sqlalchemy import select
            stmt = select(SessionState).where(SessionState.id == "default")
            state_obj = session.scalar(stmt)
            if state_obj is None:
                state_obj = SessionState(id="default", dirty_shutdown=1)
                session.add(state_obj)
            else:
                state_obj.dirty_shutdown = 1
                state_obj.session_start = datetime.utcnow()

            session.commit()
    except Exception as e:
        if self.verbose:
            print(f"Warning: Could not mark session dirty: {e}")
```

**Step 3: Integrate session persistence into ProcessManager lifecycle:**

Update `shutdown()` method in `manager.py`:

```python
def shutdown(self) -> None:
    """Terminate all processes gracefully and save session state."""
    # Save session state before terminating
    self.save_session(active_workflows=[])

    # Terminate processes (existing code)
    for name, process in self._processes.items():
        if process.is_alive():
            process.terminate()

    # Wait with timeout
    for name, process in self._processes.items():
        process.join(timeout=5)
        if process.is_alive():
            if self.verbose:
                print(f"Killing {name} (did not shut down gracefully)")
            process.kill()
```

**Step 4: Update `cmd_ui()` in `cli.py` to check for crash restoration:**

```python
def cmd_ui(args: argparse.Namespace) -> int:
    """Launch the complete Configurable Agents UI (Dashboard + Chat)."""
    from configurable_agents.process import ProcessManager, ServiceSpec

    # ... existing imports and setup ...

    # Create ProcessManager
    manager = ProcessManager(verbose=args.verbose)

    # Check for previous crash (dirty shutdown)
    restore_data = manager.check_restore_session()
    if restore_data:
        console.print("[yellow]![/yellow] [bold]Previous session did not shut down cleanly[/bold]")
        if restore_data.get("active_workflows"):
            console.print(f"  [dim]Active workflows at time of crash: {len(restore_data['active_workflows'])}[/dim]")
        console.print("[dim]Session state saved. Use dashboard to review workflow status.[/dim]")
        console.print()

    # Mark session as dirty (crash detection for next run)
    manager.mark_session_dirty()

    # ... rest of existing cmd_ui code ...

    # In shutdown handler (KeyboardInterrupt except block):
    except KeyboardInterrupt:
        if console:
            console.print(f"\n[yellow]Shutting down...[/yellow]")
        else:
            print_info("\nShutting down...")

        # Shutdown processes (this saves session and marks clean)
        manager.shutdown()

        if console:
            console.print(f"[green]All services stopped[/green]")
        else:
            print_success("All services stopped")
        return 0
```
  </action>
  <verify>
# Test SessionState model creation
python -c "from configurable_agents.storage.models import SessionState; print('SessionState imported successfully'); assert hasattr(SessionState, 'is_dirty'); assert hasattr(SessionState, 'mark_clean')"

# Test ProcessManager has session methods
python -c "from configurable_agents.process import ProcessManager; assert hasattr(ProcessManager, 'save_session'); assert hasattr(ProcessManager, 'check_restore_session'); assert hasattr(ProcessManager, 'mark_session_dirty'); print('Session methods exist')"

# Verify dirty_shutdown column type is Integer (SQLite boolean)
python -c "from configurable_agents.storage.models import SessionState; import sqlalchemy; col = SessionState.__table__.columns['dirty_shutdown']; print(f'dirty_shutdown type: {col.type}')"
  </verify>
  <done>
SessionState model added with dirty_shutdown flag. ProcessManager has save_session(), check_restore_session(), and mark_session_dirty() methods. cmd_ui() checks for dirty shutdown on startup and shows warning.
  </done>
</task>

</tasks>

<verification>
**Overall Phase Verification:**

1. Run `configurable-agents ui --help` and verify all options are documented
2. Run `configurable-agents ui` and verify:
   - Dashboard starts on port 7861
   - Chat UI starts on port 7860
   - Access URLs are printed
   - Ctrl+C shuts down both services cleanly
3. Run `configurable-agents ui --no-chat` and verify only Dashboard starts
4. Run `configurable-agents ui --dashboard-port 8000 --chat-port 7860` and verify custom ports work
5. Check for zombie processes after shutdown (should be none)
6. **Session restoration (STARTUP-06):**
   - Start `configurable-agents ui`, then force-kill (Ctrl+Break or kill command) to simulate crash
   - Restart `configurable-agents ui` and verify warning appears: "Previous session did not shut down cleanly"
   - Verify Ctrl+C shutdown clears dirty_shutdown flag (next startup shows no warning)
   - Check database: `sqlite3 configurable_agents.db "SELECT id, dirty_shutdown FROM session_state"`
</verification>

<success_criteria>
1. `configurable-agents ui` command launches Dashboard + Chat UI with single command
2. Rich spinners show progress ("Starting Dashboard...", "Starting Chat UI...")
3. Service URLs printed on startup (Dashboard: http://localhost:7861, Chat UI: http://localhost:7860)
4. Ctrl+C triggers graceful shutdown of all services
5. `--no-chat` flag skips Chat UI launch
6. Custom ports work via `--dashboard-port` and `--chat-port`
7. **Session restoration (STARTUP-06):**
   - Dirty shutdown is detected on next startup with warning message
   - Clean shutdown (Ctrl+C) saves session and clears dirty flag
   - Session state persisted to database (SessionState table)
</success_criteria>

<output>
After completion, create `.planning/phases/05-foundation-reliability/05-01-SUMMARY.md` with:
- Implementation details (ProcessManager design, signal handling approach)
- Session persistence design (SessionState model, dirty_shutdown flag)
- Platform compatibility notes (Windows vs Unix signal handling)
- Known issues or workarounds
- Files modified summary
</output>
