---
phase: 05-foundation-reliability
plan: 03
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - src/configurable_agents/ui/dashboard/routes/status.py
  - src/configurable_agents/ui/dashboard/templates/partials/status_panel.html
  - src/configurable_agents/ui/dashboard/templates/dashboard.html
  - src/configurable_agents/ui/dashboard/templates/errors/error.html
  - src/configurable_agents/utils/error_formatter.py
autonomous: false

must_haves:
  truths:
    - "Dashboard shows 4 status metrics (active workflows, agent health, recent errors, system resources)"
    - "Status panel refreshes automatically every 10 seconds via HTMX"
    - "Error messages include description, resolution steps, and collapsible technical details"
    - "Common errors (port in use, permission denied) have inline fix suggestions"
  artifacts:
    - path: "src/configurable_agents/ui/dashboard/routes/status.py"
      provides: "Status endpoint for HTMX polling"
      min_lines: 60
      contains: ["@router.get('/status'", "get_active_workflow_count", "get_agent_health_status", "get_recent_errors"]
    - path: "src/configurable_agents/ui/dashboard/templates/partials/status_panel.html"
      provides: "HTMX-ready status panel fragment"
      min_lines: 40
      contains: ["hx-trigger=\"every 10s\"", "Active Workflows", "Agent Health", "Recent Errors"]
    - path: "src/configurable_agents/utils/error_formatter.py"
      provides: "Error formatting utilities"
      min_lines: 40
      contains: ["class ErrorContext", "COMMON_ERRORS"]
  key_links:
    - from: "templates/partials/status_panel.html"
      to: "routes/status.py > /api/status"
      via: "hx-get attribute"
      pattern: "hx-get=\"/api/status\""
    - from: "routes/status.py"
      to: "storage repositories"
      via: "query for metrics"
      pattern: "workflow_repo|agent_registry_repo"
---

<objective>
Implement status dashboard with periodic refresh via HTMX and formatted error messages with actionable resolution steps.

**Purpose:** Users can see system status at a glance (active workflows, agent health, recent errors) with automatic updates, and errors provide clear guidance on resolution.

**Output:** Status endpoint returning HTML fragment, status panel template with HTMX polling, and error formatter with resolution steps.
</objective>

<execution_context>
@C:\Users\ghost\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\ghost\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/phases/05-foundation-reliability/05-CONTEXT.md
@.planning/phases/05-foundation-reliability/05-RESEARCH.md
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Existing code to build on
@src/configurable_agents/ui/dashboard/app.py
@src/configurable_agents/ui/dashboard/templates/dashboard.html
@src/configurable_agents/storage/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create status endpoint returning HTML fragment</name>
  <files>src/configurable_agents/ui/dashboard/routes/status.py</files>
  <action>
Create `src/configurable_agents/ui/dashboard/routes/status.py` with status endpoint:

```python
"""Status dashboard routes for HTMX polling.

Provides periodic status updates for the dashboard showing
active workflows, agent health, recent errors, and system resources.
"""

import psutil
from datetime import datetime, timedelta
from typing import Dict, List, Optional

from fastapi import APIRequest, Response
from fastapi.responses import HTMLResponse

from configurable_agents.storage.base import (
    AbstractWorkflowRunRepository,
    AgentRegistryRepository,
)
from configurable_agents.storage.models import WorkflowRunRecord, AgentRecord


class StatusMetrics:
    """Container for status dashboard metrics."""

    active_workflows: int
    total_workflows: int
    agent_healthy: int
    agent_total: int
    recent_errors: List[Dict[str, str]]
    cpu_percent: float
    memory_percent: float


async def get_active_workflow_count(repo: AbstractWorkflowRunRepository) -> tuple[int, int]:
    """Get count of active and total workflows.

    Args:
        repo: Workflow run repository

    Returns:
        Tuple of (active_count, total_count)
    """
    try:
        # Try to get all runs
        if hasattr(repo, 'engine'):
            from sqlalchemy import select, Session
            from configurable_agents.storage.models import WorkflowRunRecord

            with Session(repo.engine) as session:
                total_stmt = select(WorkflowRunRecord)
                active_stmt = select(WorkflowRunRecord).where(
                    WorkflowRunRecord.status == "running"
                )

                total_count = len(list(session.scalars(total_stmt).all()))
                active_count = len(list(session.scalars(active_stmt).all()))

                return active_count, total_count
        else:
            # Fallback: try list_all method
            runs = repo.list_all(limit=1000)
            active_count = sum(1 for r in runs if r.status == "running")
            return active_count, len(runs)
    except Exception:
        return 0, 0


async def get_agent_health_status(repo: AgentRegistryRepository) -> tuple[int, int]:
    """Get agent health status.

    Args:
        repo: Agent registry repository

    Returns:
        Tuple of (healthy_count, total_count)
    """
    try:
        agents = repo.list_all(include_dead=False)
        healthy_count = sum(1 for a in agents if a.is_alive())
        return healthy_count, len(agents)
    except Exception:
        return 0, 0


async def get_recent_errors(
    repo: AbstractWorkflowRunRepository,
    count: int = 5,
) -> List[Dict[str, str]]:
    """Get recent workflow errors.

    Args:
        repo: Workflow run repository
        count: Maximum number of errors to return

    Returns:
        List of error dictionaries with message and timestamp
    """
    try:
        if hasattr(repo, 'engine'):
            from sqlalchemy import select, Session, desc
            from configurable_agents.storage.models import WorkflowRunRecord

            with Session(repo.engine) as session:
                cutoff = datetime.utcnow() - timedelta(hours=24)
                stmt = (
                    select(WorkflowRunRecord)
                    .where(
                        WorkflowRunRecord.status == "failed",
                        WorkflowRunRecord.started_at >= cutoff
                    )
                    .order_by(desc(WorkflowRunRecord.started_at))
                    .limit(count)
                )

                failed_runs = list(session.scalars(stmt).all())

                return [
                    {
                        "message": run.error_message or "Unknown error",
                        "workflow": run.workflow_name,
                        "timestamp": run.started_at.strftime("%H:%M") if run.started_at else "??:??",
                    }
                    for run in failed_runs
                ]
        return []
    except Exception:
        return []


async def get_system_resources() -> tuple[float, float]:
    """Get current system resource usage.

    Returns:
        Tuple of (cpu_percent, memory_percent)
    """
    try:
        cpu = psutil.cpu_percent(interval=0.1)
        memory = psutil.virtual_memory().percent
        return cpu, memory
    except Exception:
        return 0.0, 0.0
```

Then create the route file with the actual endpoint - continue in same file:

```python
from fastapi import APIRouter, Request, Response
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

router = APIRouter()


@router.get("/api/status", response_class=HTMLResponse)
async def status_dashboard(request: Request):
    """Return status dashboard HTML fragment for HTMX polling.

    This endpoint returns an HTML fragment that replaces the status
    panel on the dashboard via HTMX's hx-swap="outerHTML".

    The fragment auto-refreshes every 10 seconds via hx-trigger.
    """
    # Get repositories from app state
    workflow_repo: AbstractWorkflowRunRepository = request.app.state.workflow_repo
    agent_repo: AgentRegistryRepository = request.app.state.agent_registry_repo
    templates: Jinja2Templates = request.app.state.templates

    # Gather metrics
    active_workflows, total_workflows = await get_active_workflow_count(workflow_repo)
    agent_healthy, agent_total = await get_agent_health_status(agent_repo)
    recent_errors = await get_recent_errors(workflow_repo, count=5)
    cpu_percent, memory_percent = await get_system_resources()

    # Render status panel fragment
    return templates.TemplateResponse(
        "partials/status_panel.html",
        {
            "request": request,
            "active_workflows": active_workflows,
            "total_workflows": total_workflows,
            "agent_healthy": agent_healthy,
            "agent_total": agent_total,
            "recent_errors": recent_errors,
            "cpu_percent": cpu_percent,
            "memory_percent": memory_percent,
        },
    )


@router.get("/api/status/health")
async def health_check(request: Request):
    """Simple health check endpoint.

    Returns JSON with overall system health status.
    """
    workflow_repo: AbstractWorkflowRunRepository = request.app.state.workflow_repo
    agent_repo: AgentRegistryRepository = request.app.state.agent_registry_repo

    active_workflows, _ = await get_active_workflow_count(workflow_repo)
    agent_healthy, _ = await get_agent_health_status(agent_repo)

    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "active_workflows": active_workflows,
        "healthy_agents": agent_healthy,
    }
```
  </action>
  <verify>
# Test that the module imports correctly
python -c "from configurable_agents.ui.dashboard.routes import status; print('Import successful')"

# Verify functions exist
python -c "from configurable_agents.ui.dashboard.routes.status import get_active_workflow_count, get_agent_health_status, get_recent_errors; print('Functions exported')"
  </verify>
  <done>
Status route module created with helper functions for querying metrics. All functions import correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create status panel template with HTMX polling</name>
  <files>src/configurable_agents/ui/dashboard/templates/partials/status_panel.html</files>
  <action>
Create `src/configurable_agents/ui/dashboard/templates/partials/status_panel.html`:

```html
<div class="status-panel" hx-get="/api/status" hx-trigger="load, every 10s" hx-swap="outerHTML">
  <div class="status-grid">
    <!-- Active Workflows -->
    <div class="status-card {{ 'status-ok' if active_workflows == 0 else 'status-active' }}">
      <div class="status-icon workflow-icon"></div>
      <div class="status-content">
        <h4>Active Workflows</h4>
        <p class="status-value">{{ active_workflows }} / {{ total_workflows }}</p>
        <span class="status-label">running / total</span>
      </div>
    </div>

    <!-- Agent Health -->
    <div class="status-card {{ 'status-ok' if agent_healthy == agent_total else 'status-warning' }}">
      <div class="status-icon agent-icon"></div>
      <div class="status-content">
        <h4>Agent Health</h4>
        <p class="status-value">{{ agent_healthy }} / {{ agent_total }}</p>
        <span class="status-label">healthy / total</span>
      </div>
    </div>

    <!-- System Resources -->
    <div class="status-card {{ 'status-ok' if cpu_percent < 80 and memory_percent < 80 else 'status-warning' }}">
      <div class="status-icon resource-icon"></div>
      <div class="status-content">
        <h4>System Resources</h4>
        <p class="status-value">CPU {{ cpu_percent|int }}% | RAM {{ memory_percent|int }}%</p>
        <span class="status-label">current usage</span>
      </div>
    </div>

    <!-- Recent Errors -->
    <div class="status-card {{ 'status-ok' if recent_errors|length == 0 else 'status-error' }}">
      <div class="status-icon error-icon"></div>
      <div class="status-content">
        <h4>Recent Errors</h4>
        {% if recent_errors %}
        <p class="status-value">{{ recent_errors|length }}</p>
        <span class="status-label">in last 24h</span>
        {% if recent_errors[:1] %}
        <div class="error-preview">
          <span class="error-workflow">{{ recent_errors[0].workflow }}</span>
          <span class="error-time">{{ recent_errors[0].timestamp }}</span>
        </div>
        {% endif %}
        {% else %}
        <p class="status-value">0</p>
        <span class="status-label">no errors</span>
        {% endif %}
      </div>
    </div>
  </div>

  {% if recent_errors %}
  <div class="recent-errors-list">
    <h5>Recent Errors (Last 24h)</h5>
    {% for error in recent_errors[:3] %}
    <div class="error-item">
      <span class="error-workflow">{{ error.workflow }}</span>
      <span class="error-message">{{ error.message[:50] }}{% if error.message|length > 50 %}...{% endif %}</span>
      <span class="error-time">{{ error.timestamp }}</span>
    </div>
    {% endfor %}
  </div>
  {% endif %}

  <div class="status-footer">
    <span class="last-updated">Updated: <time datetime="{{ datetime.utcnow().isoformat() }}">{{ datetime.utcnow().strftime("%H:%M:%S") }}</time></span>
  </div>
</div>
```

**Also create the directory if needed:**
```bash
mkdir -p src/configurable_agents/ui/dashboard/templates/partials
```

**Add CSS styles to `static/dashboard.css` (or create if doesn't exist):**

```css
/* Status Panel Styles */
.status-panel {
  background: var(--card-bg);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 24px;
}

.status-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
}

.status-card {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px;
  border-radius: 8px;
  background: var(--card-bg);
  border: 1px solid var(--border-color);
}

.status-card.status-ok { border-left: 4px solid #10b981; }
.status-card.status-active { border-left: 4px solid #3b82f6; }
.status-card.status-warning { border-left: 4px solid #f59e0b; }
.status-card.status-error { border-left: 4px solid #ef4444; }

.status-icon {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: var(--bg-secondary);
  display: flex;
  align-items: center;
  justify-content: center;
}

.status-content h4 {
  margin: 0 0 4px 0;
  font-size: 12px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.status-content .status-value {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
  color: var(--text-primary);
}

.status-content .status-label {
  font-size: 12px;
  color: var(--text-secondary);
}

.error-preview {
  margin-top: 8px;
  font-size: 11px;
  color: var(--text-secondary);
}

.recent-errors-list {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-color);
}

.recent-errors-list h5 {
  margin: 0 0 8px 0;
  font-size: 14px;
  color: var(--text-secondary);
}

.error-item {
  display: flex;
  gap: 8px;
  padding: 8px;
  border-radius: 4px;
  background: var(--bg-secondary);
  margin-bottom: 4px;
}

.error-workflow {
  font-weight: 500;
  min-width: 100px;
}

.error-message {
  flex: 1;
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.error-time {
  color: var(--text-secondary);
  font-size: 12px;
}

.status-footer {
  margin-top: 12px;
  text-align: right;
}

.status-footer .last-updated {
  font-size: 11px;
  color: var(--text-secondary);
}
```
  </action>
  <verify>
# Check that the template file exists
ls -la src/configurable_agents/ui/dashboard/templates/partials/status_panel.html

# Verify HTMX attributes are present
grep -n "hx-trigger" src/configurable_agents/ui/dashboard/templates/partials/status_panel.html
grep -n "hx-get" src/configurable_agents/ui/dashboard/templates/partials/status_panel.html
grep -n "hx-swap" src/configurable_agents/ui/dashboard/templates/partials/status_panel.html
  </verify>
  <done>
Status panel template created with HTMX polling attributes (hx-trigger="load, every 10s", hx-get="/api/status", hx-swap="outerHTML"). Template shows 4 metrics in a grid layout.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate status panel into dashboard and register routes</name>
  <files>src/configurable_agents/ui/dashboard/app.py, src/configurable_agents/ui/dashboard/templates/dashboard.html</files>
  <action>
**Update `dashboard/app.py`:**

1. Import and register the status router:
   Add to `_include_routers()` method:

```python
def _include_routers(self) -> None:
    """Include dashboard routers."""
    from configurable_agents.ui.dashboard.routes import (
        workflows_router,
        agents_router,
        metrics_router,
        optimization_router,
        orchestrator_router,
    )
    from configurable_agents.ui.dashboard.routes import status as status_routes

    self.app.include_router(workflows_router)
    self.app.include_router(agents_router)
    self.app.include_router(metrics_router)
    self.app.include_router(optimization_router)
    self.app.include_router(orchestrator_router)
    self.app.include_router(status_routes.router)  # NEW
```

**Update `dashboard.html` template:**

Replace the summary cards section with the new status panel:

```html
{% extends "base.html" %}

{% block title %}Dashboard - Configurable Agents{% endblock %}

{% block nav_dashboard %}class="active"{% endblock %}

{% block content %}
<div class="dashboard-container">
    <header class="page-header">
        <h1>Dashboard</h1>
        <p class="subtitle">Real-time workflow and agent monitoring</p>
    </header>

    <!-- Status Panel with auto-refresh -->
    {% include "partials/status_panel.html" %}

    <!-- Quick Links -->
    <div class="quick-links">
        <a href="/workflows" class="quick-link">
            <h3>View Workflows</h3>
            <p>See all workflow runs with status and metrics</p>
        </a>
        <a href="/agents" class="quick-link">
            <h3>View Agents</h3>
            <p>Check registered agents and health status</p>
        </a>
        <a href="/mlflow" class="quick-link">
            <h3>MLFlow UI</h3>
            <p>Access detailed experiment tracking</p>
        </a>
    </div>
</div>
{% endblock %}
```

**Create `partials` directory if it doesn't exist and add a placeholder or empty `__init__.py`:**

```bash
# Create partials directory if needed
mkdir -p src/configurable_agents/ui/dashboard/templates/partials
touch src/configurable_agents/ui/dashboard/templates/partials/.gitkeep
```
  </action>
  <verify>
# Verify the dashboard template includes the status panel
grep -n "partials/status_panel.html" src/configurable_agents/ui/dashboard/templates/dashboard.html

# Verify the router is registered in app.py
grep -n "status_routes" src/configurable_agents/ui/dashboard/app.py
  </verify>
  <done>
Dashboard template updated to include status panel via `{% include "partials/status_panel.html" %}`. Status router registered in DashboardApp.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create error formatter with resolution steps</name>
  <files>src/configurable_agents/utils/error_formatter.py, src/configurable_agents/ui/dashboard/templates/errors/error.html</files>
  <action>
**Create `src/configurable_agents/utils/__init__.py`:**

```python
from configurable_agents.utils.error_formatter import (
    ErrorContext,
    format_error_for_cli,
    format_error_for_html,
    COMMON_ERRORS,
)

__all__ = [
    "ErrorContext",
    "format_error_for_cli",
    "format_error_for_html",
    "COMMON_ERRORS",
]
```

**Create `src/configurable_agents/utils/error_formatter.py`:**

```python
"""Error formatting utilities with actionable resolution steps.

Provides structured error contexts with descriptions, resolution steps,
and technical details for common error scenarios.
"""

from dataclasses import dataclass
from typing import List, Optional, Dict
from functools import partial


@dataclass
class ErrorContext:
    """Structured error context with actionable resolution.

    Attributes:
        title: Short error title
        description: Human-readable error description
        resolution_steps: List of steps to resolve the error
        technical_details: Optional technical details (stack traces, file paths)
        error_type: Type of error for categorization
    """

    title: str
    description: str
    resolution_steps: List[str]
    technical_details: Optional[str] = None
    error_type: str = "general"


# Common error patterns with pre-defined resolution steps
COMMON_ERRORS: Dict[str, ErrorContext] = {
    "port_in_use": ErrorContext(
        title="Port Already in Use",
        description="The specified port is already in use by another application.",
        resolution_steps=[
            "Stop the application using this port",
            "Or use a different port via --port flag",
            "On Windows: Run `netstat -ano | findstr :PORT` to find the process",
            "On Linux/macOS: Run `lsof -i :PORT` to find the process",
            "Kill the process with `taskkill /PID <pid> /F` (Windows) or `kill <pid>` (Unix)",
        ],
        error_type="network",
    ),
    "permission_denied": ErrorContext(
        title="Permission Denied",
        description="The application does not have permission to access the specified resource.",
        resolution_steps=[
            "Check file/directory permissions",
            "Ensure the database directory is writable",
            "Try running with elevated privileges if needed",
            "Set AGENTS_DB_PATH to a writable location",
        ],
        error_type="filesystem",
    ),
    "disk_full": ErrorContext(
        title="Disk Full",
        description="No disk space available to write to the database.",
        resolution_steps=[
            "Free up disk space",
            "Clear old workflow runs or logs",
            "Change database location via AGENTS_DB_PATH",
        ],
        error_type="filesystem",
    ),
    "database_locked": ErrorContext(
        title="Database Locked",
        description="The database is locked by another process.",
        resolution_steps=[
            "Ensure only one instance is running",
            "Close any other applications using the database",
            "If the issue persists, restart the application",
        ],
        error_type="database",
    ),
    "module_not_found": ErrorContext(
        title="Missing Dependency",
        description="A required Python module is not installed.",
        resolution_steps=[
            "Install missing dependencies: pip install -e .",
            "Ensure virtual environment is activated",
            "Check requirements.txt for all dependencies",
        ],
        error_type="dependency",
    ),
    "invalid_config": ErrorContext(
        title="Invalid Configuration",
        description="The workflow configuration file is invalid.",
        resolution_steps=[
            "Validate config with: configurable-agents validate <config.yaml>",
            "Check YAML syntax (indentation, colons)",
            "Verify all required fields are present",
            "See docs for config schema reference",
        ],
        error_type="configuration",
    ),
}


def get_error_context(error: Exception) -> ErrorContext:
    """Get ErrorContext for an exception.

    Args:
        error: The exception to format

    Returns:
        ErrorContext with title, description, and resolution steps
    """
    error_str = str(error).lower()

    # Match against common error patterns
    if "port" in error_str and ("use" in error_str or "occupied" in error_str or "already" in error_str):
        return COMMON_ERRORS["port_in_use"]
    elif "permission" in error_str or "denied" in error_str or "access" in error_str:
        return COMMON_ERRORS["permission_denied"]
    elif "disk" in error_str or "space" in error_str or "no space" in error_str:
        return COMMON_ERRORS["disk_full"]
    elif "locked" in error_str or "database is locked" in error_str:
        return COMMON_ERRORS["database_locked"]
    elif "module" in error_str and "not found" in error_str:
        return COMMON_ERRORS["module_not_found"]
    elif "config" in error_str or "validation" in error_str or "invalid" in error_str:
        return COMMON_ERRORS["invalid_config"]

    # Generic error context
    return ErrorContext(
        title=error.__class__.__name__,
        description=str(error) or "An unexpected error occurred.",
        resolution_steps=[
            "Check the error details below",
            "Review logs for more information",
            "Try again with --verbose flag for more details",
        ],
        error_type="general",
    )


def format_error_for_cli(error: Exception, verbose: bool = False) -> str:
    """Format error for CLI output with colors and resolution steps.

    Args:
        error: The exception to format
        verbose: Include technical details if True

    Returns:
        Formatted error string with ANSI colors
    """
    ctx = get_error_context(error)

    lines = [
        f"\033[91m\033[1mError: {ctx.title}\033[0m",  # Red bold title
        f"\033[90m{ctx.description}\033[0m",  # Gray description
        "",
        "\033[93mHow to fix:\033[0m",  # Yellow "How to fix:"
    ]

    for i, step in enumerate(ctx.resolution_steps, 1):
        lines.append(f"  {i}. {step}")

    if verbose and ctx.technical_details:
        lines.extend([
            "",
            "\033[90mTechnical details:\033[0m",
            f"\033[90m{ctx.technical_details}\033[0m",
        ])

    return "\n".join(lines)


def format_error_for_html(error: Exception, verbose: bool = False) -> dict:
    """Format error for HTML rendering.

    Args:
        error: The exception to format
        verbose: Include technical details if True

    Returns:
        Dictionary with error context for template rendering
    """
    ctx = get_error_context(error)

    return {
        "title": ctx.title,
        "description": ctx.description,
        "resolution_steps": ctx.resolution_steps,
        "technical_details": ctx.technical_details if verbose else None,
        "error_type": ctx.error_type,
    }
```

**Create `src/configurable_agents/ui/dashboard/templates/errors/error.html`:**

```html
{% macro error_card(error) -%}
<div class="error-container">
  <div class="error-header">
    <span class="error-icon">⚠</span>
    <h2 class="error-title">{{ error.title }}</h2>
  </div>

  <p class="error-description">{{ error.description }}</p>

  <div class="error-resolution">
    <h3>How to fix this:</h3>
    <ol class="resolution-steps">
      {% for step in error.resolution_steps %}
      <li>{{ step }}</li>
      {% endfor %}
    </ol>
  </div>

  {% if error.technical_details %}
  <details class="error-details">
    <summary>Show technical details</summary>
    <pre class="error-stacktrace">{{ error.technical_details }}</pre>
  </details>
  {% endif %}
</div>
{%- endmacro %}

{# Usage example: #}
{# {{ error_card(error) }} #}
```
  </action>
  <verify>
# Test that the error formatter imports correctly
python -c "from configurable_agents.utils import error_formatter; print('Import successful')"

# Test common errors exist
python -c "from configurable_agents.utils.error_formatter import COMMON_ERRORS; assert 'port_in_use' in COMMON_ERRORS; assert 'permission_denied' in COMMON_ERRORS; print('Common errors defined')"

# Test formatting
python -c "
from configurable_agents.utils.error_formatter import format_error_for_cli
class TestError(Exception):
    pass
try:
    raise TestError('Permission denied accessing file')
except Exception as e:
    output = format_error_for_cli(e)
    print(output)
    if 'How to fix:' in output:
        print('✓ Resolution steps included')
"
  </verify>
  <done>
Error formatter module created with `ErrorContext`, `COMMON_ERRORS` dictionary, and `format_error_for_cli()`/`format_error_for_html()` functions. HTML template macro for error card created.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete status dashboard with HTMX polling and formatted error messages</what-built>
  <how-to-verify>
1. Start the dashboard: `configurable-agents ui`
2. Open http://localhost:7861 in a browser
3. Verify the status panel appears with 4 metrics (Active Workflows, Agent Health, System Resources, Recent Errors)
4. Wait 10-20 seconds and verify the "Updated:" timestamp changes (HTMX polling working)
5. Check browser dev tools Network tab for requests to /api/status
6. Trigger an error (e.g., try to start dashboard on occupied port) and verify error message includes "How to fix:" section
  </how-to-verify>
  <resume-signal>Type "approved" if status dashboard is working correctly and polling updates are visible. Otherwise describe issues.</resume-signal>
</task>

</tasks>

<verification>
**Overall Phase Verification:**

1. Run `configurable-agents ui` and verify status panel displays on dashboard
2. Check that status panel shows 4 metrics with correct data
3. Wait 10+ seconds and verify the timestamp updates (HTMX polling)
4. Check browser Network tab for periodic `/api/status` requests
5. Test error formatting by triggering a common error (port in use, permission denied)
6. Verify error messages include "How to fix:" section with actionable steps
7. Verify technical details are collapsible (HTML `<details>` element)
</verification>

<success_criteria>
1. Status panel displays 4 metrics: Active Workflows, Agent Health, System Resources, Recent Errors
2. HTMX polling refreshes status every 10 seconds (`hx-trigger="load, every 10s"`)
3. Status endpoint returns HTML fragment (`hx-swap="outerHTML"`)
4. Error messages include title, description, and numbered resolution steps
5. Technical details collapsed by default (`<details>` element)
6. Common errors (port in use, permission denied, disk full) have specific resolution steps
</success_criteria>

<output>
After completion, create `.planning/phases/05-foundation-reliability/05-03-SUMMARY.md` with:
- Status dashboard implementation details
- HTMX polling configuration
- Error formatter patterns
- Known issues or workarounds
- Files modified summary
</output>
