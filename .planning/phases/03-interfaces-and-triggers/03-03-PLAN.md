---
phase: 03-interfaces-and-triggers
plan: 03
type: execute
wave: 2
depends_on: [01, 02]
files_modified:
  - src/configurable_agents/webhooks/__init__.py
  - src/configurable_agents/webhooks/base.py
  - src/configurable_agents/webhooks/whatsapp.py
  - src/configurable_agents/webhooks/telegram.py
  - src/configurable_agents/webhooks/router.py
  - src/configurable_agents/runtime/executor.py
  - src/configurable_agents/storage/models.py
  - src/configurable_agents/storage/base.py
  - src/configurable_agents/storage/sqlite.py
  - src/configurable_agents/storage/factory.py
  - src/configurable_agents/storage/__init__.py
  - tests/webhooks/test_base.py
  - tests/webhooks/test_whatsapp.py
  - tests/webhooks/test_telegram.py
  - tests/webhooks/test_router.py
autonomous: false
user_setup:
  - service: telegram
    why: "Telegram Bot API for triggering workflows via chat messages"
    env_vars:
      - name: TELEGRAM_BOT_TOKEN
        source: "BotFather on Telegram - create new bot and get token"
    dashboard_config:
      - task: "Create Telegram bot"
        location: "Open Telegram, search @BotFather, send /newbot, follow prompts"
  - service: whatsapp
    why: "WhatsApp Business API for triggering workflows via messages"
    env_vars:
      - name: WHATSAPP_PHONE_ID
        source: "Meta for Developers - create WhatsApp app, get phone ID"
      - name: WHATSAPP_ACCESS_TOKEN
        source: "Meta for Developers - generate access token for WhatsApp app"
      - name: WHATSAPP_VERIFY_TOKEN
        source: "User-defined secret for webhook verification"
    dashboard_config:
      - task: "Configure WhatsApp webhook"
        location: "Meta for Developers - WhatsApp > Configuration > Webhooks"

must_haves:
  truths:
    - "User can send a WhatsApp message that triggers a workflow execution and receive the result back in the same chat"
    - "User can send a Telegram message that triggers a workflow execution and receive the result back in the same chat"
    - "Generic webhook endpoint accepts POST requests with workflow_name and inputs"
    - "Webhook signatures are verified for security (HMAC validation)"
    - "Idempotency keys prevent duplicate workflow executions from replay attacks"
  artifacts:
    - path: "src/configurable_agents/webhooks/base.py"
      provides: "Generic webhook handler with HMAC validation"
      exports: ["WebhookHandler", "verify_signature"]
    - path: "src/configurable_agents/webhooks/whatsapp.py"
      provides: "WhatsApp webhook handler"
      exports: ["WhatsAppWebhookHandler", "extract_phone", "extract_message"]
    - path: "src/configurable_agents/webhooks/telegram.py"
      provides: "Telegram webhook handler via aiogram"
      exports: ["create_telegram_bot", "create_dispatcher", "handle_telegram_webhook"]
    - path: "src/configurable_agents/webhooks/router.py"
      provides: "FastAPI router with webhook endpoints"
      exports: ["router as webhooks_router"]
    - path: "src/configurable_agents/runtime/executor.py"
      provides: "run_workflow_async function for webhook triggers"
      exports: ["run_workflow_async"]
    - path: "src/configurable_agents/storage/models.py"
      provides: "WebhookEventRecord for idempotency tracking"
      contains: "class WebhookEventRecord"
  key_links:
    - from: "src/configurable_agents/webhooks/router.py"
      to: "src/configurable_agents/runtime/executor.py"
      via: "run_workflow_async() for background workflow execution"
      pattern: "run_workflow_async"
    - from: "src/configurable_agents/webhooks/base.py"
      to: "src/configurable_agents/storage"
      via: "WebhookEventRepository for idempotency key tracking"
      pattern: "WebhookEventRepository"
    - from: "src/configurable_agents/webhooks/whatsapp.py"
      to: "https://graph.facebook.com"
      via: "WhatsApp Cloud API for sending messages"
      pattern: "https://graph.facebook.com"
    - from: "src/configurable_agents/webhooks/telegram.py"
      to: "https://api.telegram.org"
      via: "Telegram Bot API for sending messages"
      pattern: "aiogram|Bot.*token"
---

<objective>
Build webhook integrations for WhatsApp Business API and Telegram Bot API that allow users to trigger workflow executions by sending messages, with HMAC signature validation, idempotency protection, and async result delivery.

Purpose: Enable external triggering of workflows from popular messaging platforms. Users send messages in format "/workflow_name <input>" and receive workflow results back in the same chat. Generic webhook endpoint enables third-party integrations.

Output: Webhook handlers at /webhooks/whatsapp, /webhooks/telegram, /webhooks/generic with signature validation and idempotency tracking
</objective>

<execution_context>
@C:\Users\ghost\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\ghost\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-interfaces-and-triggers/03-RESEARCH.md
@.planning/phases/01-core-engine/01-04-SUMMARY.md
@.planning/phases/02-agent-infrastructure/02-01A-SUMMARY.md

@src/configurable_agents/runtime/executor.py
@src/configurable_agents/config/schema.py
@src/configurable_agents/storage/models.py
@src/configurable_agents/storage/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook storage and async workflow execution</name>
  <files>src/configurable_agents/storage/models.py, src/configurable_agents/storage/base.py, src/configurable_agents/storage/sqlite.py, src/configurable_agents/storage/factory.py, src/configurable_agents/storage/__init__.py, src/configurable_agents/runtime/executor.py</files>
  <action>
    Add webhook idempotency tracking and async workflow execution:

    1. **Add WebhookEventRecord ORM model to models.py:**
       - __tablename__ = "webhook_events"
       - Fields: id (Integer, autoincrement PK), webhook_id (String(255), unique, indexed), provider (String(64)), processed_at (DateTime, default=datetime.utcnow)
       - Unique constraint on webhook_id prevents duplicate processing

    2. **Add WebhookEventRepository to base.py:**
       - is_processed(webhook_id: str) -> bool: Check if webhook event was already processed
       - mark_processed(webhook_id: str, provider: str) -> None: Record webhook as processed
       - cleanup_old_events(days: int = 7) -> int: Delete records older than N days, return count deleted

    3. **Add SqliteWebhookEventRepository to sqlite.py:**
       - Implement all methods using AsyncSession
       - Use INSERT OR IGNORE for idempotent mark_processed()
       - Follow existing repository patterns

    4. **Update factory.py and storage/__init__.py:**
       - create_storage_backend() now returns 6-tuple (add webhook_event_repo)
       - Export WebhookEventRepository and SqliteWebhookEventRepository

    5. **Add run_workflow_async() to runtime/executor.py:**
       - async def run_workflow_async(config_path: str, inputs: Dict[str, Any]) -> Dict[str, Any]
       - Wraps existing run_workflow_from_config() in async wrapper using asyncio.to_thread()
       - Enables background task execution from FastAPI endpoints
       - Raises same exceptions as run_workflow() for proper error handling

    Reference research: .planning/phases/03-interfaces-and-triggers/03-RESEARCH.md lines 487-576, 1106-1121
    Use existing patterns from 01-01A for SQLAlchemy repositories
  </action>
  <verify>
    from configurable_agents.storage import WebhookEventRepository, create_storage_backend
    from configurable_agents.runtime.executor import run_workflow_async

    # Test repository
    _, _, _, _, _, webhook_repo = create_storage_backend(None)
    assert not await webhook_repo.is_processed("test-id")
    await webhook_repo.mark_processed("test-id", "test-provider")
    assert await webhook_repo.is_processed("test-id")

    # Test async executor (if test workflow exists)
    # result = await run_workflow_async("tests/fixtures/simple_workflow.yaml", {"input": "test"})
    # assert result is not None
  </verify>
  <done>
    WebhookEventRecord ORM model created
    WebhookEventRepository interface defined and implemented
    create_storage_backend() returns 6-tuple with webhook_event_repo
    run_workflow_async() function works for background execution
    Idempotency tracking prevents duplicate processing
  </done>
</task>

<task type="auto">
  <name>Task 2: Create generic webhook handler with HMAC validation</name>
  <files>src/configurable_agents/webhooks/__init__.py, src/configurable_agents/webhooks/base.py</files>
  <action>
    Create base webhook handler with security features:

    1. **Create webhooks package:**
       - src/configurable_agents/webhooks/__init__.py: Exports for WebhookHandler, verify_signature

    2. **Create base.py with security utilities:**
       - HMAC signature validation using hmac.compare_digest() for timing-attack safety

       def verify_signature(payload: bytes, signature: str, secret: str, algorithm: str = "sha256") -> bool:
         * Compute expected HMAC hash of payload using secret
         * Remove algorithm prefix if present (e.g., "sha256=")
         * Use hmac.compare_digest() for constant-time comparison
         * Return True if valid, False otherwise

       class WebhookHandler:
         * __init__(secret: str, signature_header: str = "X-Signature", algorithm: str = "sha256")
         * verify_request(request: Request) -> bool: Read body, extract signature, verify
         * async def handle_webhook(self, request: Request, handler_func: Callable, webhook_repo: WebhookEventRepository) -> dict:
           - Verify signature
           - Check for replay attack using webhook_id
           - Parse JSON payload
           - Call handler_func with validated data
           - Return handler response

       class WebhookError(Exception): Base exception for webhook errors
       class InvalidSignatureError(WebhookError): Raised when signature verification fails
       class ReplayAttackError(WebhookError): Raised when webhook_id already processed

    Reference research: .planning/phases/03-interfaces-and-triggers/03-RESEARCH.md lines 487-576
  </action>
  <verify>
    from configurable_agents.webhooks.base import verify_signature, WebhookHandler

    # Test signature verification
    secret = "test-secret"
    payload = b"test-payload"
    import hmac
    import hashlib
    expected = hmac.new(secret.encode(), payload, hashlib.sha256).hexdigest()

    assert verify_signature(payload, expected, secret)

    # Test WebhookHandler creation
    handler = WebhookHandler(secret=secret, signature_header="X-Signature")
    assert handler.secret == secret.encode()
    assert handler.signature_header == "X-Signature"
  </verify>
  <done>
    verify_signature() function with constant-time comparison
    WebhookHandler class with signature validation
    Replay attack detection via webhook_id
    Proper exception hierarchy for webhook errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create WhatsApp webhook handler</name>
  <files>src/configurable_agents/webhooks/whatsapp.py</files>
  <action>
    Create WhatsApp Business API webhook handler:

    1. **Create whatsapp.py:**
       - WhatsAppWebhookHandler class
       - __init__(phone_id: str, access_token: str, verify_token: str)
       - verify_webhook(mode: str, token: str, challenge: str) -> Optional[int]: Meta webhook verification (returns challenge on success)

       extract_phone(data: dict) -> Optional[str]:
         * Parse Meta webhook payload format
         * Extract phone number from entry[0].changes[0].value.messages[0].from
         * Return None if no message

       extract_message(data: dict) -> Optional[str]:
         * Extract text body from message payload
         * Return None if no message

       async def send_message(phone_number: str, text: str) -> None:
         * POST to https://graph.facebook.com/v18.0/{phone_id}/messages
         * Headers: Authorization: Bearer {access_token}
         * Body: {"messaging_product": "whatsapp", "to": phone_number, "type": "text", "text": {"body": text}}
         * Use httpx.AsyncClient for async HTTP

       parse_workflow_command(message: str) -> Optional[Tuple[str, str]]:
         * Parse "/workflow_name input" format
         * Return (workflow_name, workflow_input) or None

       async def handle_message(phone: str, message: str, background_tasks: BackgroundTasks) -> str:
         * Parse workflow command
         * Add background task to execute workflow
         * Return acknowledgment message

    Reference research: .planning/phases/03-interfaces-and-triggers/03-RESEARCH.md lines 576-680
    Use httpx for async HTTP (matching 02-01A patterns)
  </action>
  <verify>
    from configurable_agents.webhooks.whatsapp import WhatsAppWebhookHandler

    handler = WhatsAppWebhookHandler(
        phone_id="test-phone-id",
        access_token="test-token",
        verify_token="test-verify"
    )

    # Test verification
    assert handler.verify_webhook("subscribe", "test-verify", "challenge") == "challenge"
    assert handler.verify_webhook("subscribe", "wrong-token", "challenge") is None

    # Test command parsing
    result = handler.parse_workflow_command("/my_workflow input data")
    assert result == ("my_workflow", "input data")

    result = handler.parse_workflow_command("invalid format")
    assert result is None
  </verify>
  <done>
    WhatsAppWebhookHandler with Meta verification
    Message and phone extraction from webhook payload
    Workflow command parsing for "/workflow_name input" format
    Async send_message() using httpx
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Telegram webhook handler with aiogram</name>
  <files>src/configurable_agents/webhooks/telegram.py</files>
  <action>
    Create Telegram Bot API webhook handler using aiogram 3.x:

    1. **Create telegram.py:**
       - from aiogram import Bot, Dispatcher, types
       - from aiogram.filters import Command

       - create_telegram_bot(token: str) -> Bot: Factory for Bot instance
       - create_dispatcher() -> Dispatcher: Factory for Dispatcher

       - register_workflow_handlers(dispatcher: Dispatcher, run_workflow_func: Callable):
         * @dp.message(Command("start")): Send welcome message with usage instructions
         * @dp.message(): Handle workflow trigger messages
         * Parse "/workflow_name input" format
         * Send "typing" action via bot.send_chat_action()
         * Call run_workflow_func in background
         * Send result back (split if >4096 chars per Telegram limit)

       async def handle_telegram_webhook(request: Request, bot: Bot, dispatcher: Dispatcher) -> dict:
         * Parse Update from request.body()
         * Feed to dispatcher via await dp.feed_webhook_update(bot, update)
         * Return {"status": "ok"}

       async def send_telegram_message(bot: Bot, chat_id: int, text: str) -> None:
         * Split text into chunks of 4096 chars (Telegram limit)
         * Send each chunk via await bot.send_message()

    Reference research: .planning/phases/03-interfaces-and-triggers/03-RESEARCH.md lines 683-763
    Use aiogram 3.x async patterns (modern Python 3.10+)
  </action>
  <verify>
    from configurable_agents.webhooks.telegram import create_telegram_bot, create_dispatcher

    # Test bot creation (with dummy token for testing structure)
    bot = create_telegram_bot("dummy-token-for-testing")
    assert bot is not None

    # Test dispatcher creation
    dp = create_dispatcher()
    assert dp is not None

    # Verify handlers can be registered
    from unittest.mock import Mock
    mock_func = Mock()
    register_workflow_handlers(dp, mock_func)
    # Handlers registered (verify via dp.handlers)
  </verify>
  <done>
    Telegram Bot and Dispatcher factory functions
    Workflow handler registration function
    Command handler for /start
    Message handler for workflow triggers
    Message chunking for >4096 char results
    Webhook handler function for FastAPI integration
  </done>
</task>

<task type="checkpoint:human-verify">
  <name>Task 5: Create FastAPI webhook router and tests with manual verification</name>
  <files>src/configurable_agents/webhooks/router.py, tests/webhooks/test_base.py, tests/webhooks/test_whatsapp.py, tests/webhooks/test_telegram.py, tests/webhooks/test_router.py</files>
  <action>
    Create FastAPI router with all webhook endpoints and comprehensive tests:

    1. **Create router.py:**
       - from fastapi import APIRouter, Request, BackgroundTasks, HTTPException
       - router = APIRouter(prefix="/webhooks")

       **WhatsApp endpoints:**
       - GET /whatsapp: Webhook verification (calls WhatsAppWebhookHandler.verify_webhook())
       - POST /whatsapp: Handle incoming message (extract, parse, queue background task)

       **Telegram endpoints:**
       - POST /telegram: Handle Update via aiogram (calls handle_telegram_webhook())

       **Generic webhook endpoint:**
       - POST /generic: Accept JSON payload with workflow_name, inputs, optional webhook_id
         * Verify HMAC signature if X-Signature header present
         * Check idempotency via webhook_id
         * Run workflow via run_workflow_async()
         * Return result

       Helper functions:
       - _get_webhook_secret(provider: str) -> str: Get secret from env var (WEBHOOK_SECRET_{PROVIDER} or WEBHOOK_SECRET_DEFAULT)
       - _get_whatsapp_config() -> dict: Load WHATSAPP_* env vars
       - _get_telegram_token() -> str: Load TELEGRAM_BOT_TOKEN env var

    2. **Create tests:**
       - test_base.py: Test verify_signature(), WebhookHandler
       - test_whatsapp.py: Test WhatsAppWebhookHandler with mock HTTP
       - test_telegram.py: Test Telegram handlers with mock Bot
       - test_router.py: Test FastAPI endpoints with TestClient

       Use pytest with pytest.mark.asyncio
       Mock httpx.AsyncClient for WhatsApp tests
       Mock aiogram Bot for Telegram tests
       Mock storage repositories for idempotency tests

    3. **Add CLI command for webhook server:**
       - "configurable-agents webhooks" command
       - Options: --host, --port (default: 7862)
       - Load webhook router into FastAPI app
       - Launch with uvicorn

    Reference research: .planning/phases/03-interfaces-and-triggers/03-RESEARCH.md lines 1347-1475
  </action>
  <verify>
    pytest tests/webhooks/ -v
    # All tests pass

    # Test CLI
    configurable-agents webhooks --help
    # Shows help with --host, --port options

    # Test server launch
    configurable-agents webhooks --port 7862 &
    curl -X POST http://localhost:7862/webhooks/generic -H "Content-Type: application/json" -d '{"workflow_name":"test","inputs":{}}'
    # Returns response (200 if valid, 400/403 if invalid)
  </verify>
  <done>
    All webhook endpoints working
    HMAC signature validation on generic endpoint
    Idempotency tracking preventing replay attacks
    WhatsApp verification endpoint working
    Telegram webhook handler working
    Background tasks execute workflows async
    All tests passing with >80% coverage
    CLI command launches webhook server
  </done>
  <what-built>Webhook integrations for WhatsApp, Telegram, and generic webhook with HMAC validation and idempotency tracking</what-built>
  <how-to-verify>
    1. Automated tests: `pytest tests/webhooks/ -v`
    2. Generic webhook test: `curl -X POST http://localhost:7862/webhooks/generic -H "Content-Type: application/json" -d '{"workflow_name":"test","inputs":{"topic":"AI"}}'`
    3. Telegram setup (user action required):
       - Open Telegram, search @BotFather
       - Send /newbot, follow prompts to create bot
       - Copy BOT_TOKEN
       - Set TELEGRAM_BOT_TOKEN environment variable
       - Use webhook or ngrok to expose localhost:7862
       - Set webhook URL for your bot
       - Send "/workflow_name input" to your bot
       - Verify workflow executes and result returned
    4. WhatsApp setup (optional, user action required):
       - Create WhatsApp app in Meta for Developers
       - Get PHONE_ID, ACCESS_TOKEN, set VERIFY_TOKEN
       - Set env vars: WHATSAPP_PHONE_ID, WHATSAPP_ACCESS_TOKEN, WHATSAPP_VERIFY_TOKEN
       - Configure webhook URL in Meta dashboard
       - Send message to WhatsApp number
       - Verify workflow executes
  </how-to-verify>
  <resume-signal>Type "approved" if webhooks are working, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
After completing all tasks, verify:

1. **Webhook tests pass:**
   ```bash
   pytest tests/webhooks/ -v
   ```

2. **Import verification:**
   ```bash
   python -c "from configurable_agents.webhooks import router; from configurable_agents.runtime.executor import run_workflow_async; print('OK')"
   ```

3. **CLI verification:**
   ```bash
   configurable-agents webhooks --help
   ```

4. **Manual verification (checkpoint):**
   See Task 5 checkpoint for detailed manual verification steps including Telegram bot setup and WhatsApp configuration.
</verification>

<success_criteria>
1. Webhook server launches via CLI on port 7862
2. GET /webhooks/whatsapp returns challenge for Meta verification
3. POST /webhooks/whatsapp accepts messages and triggers workflows
4. POST /webhooks/telegram accepts updates and triggers workflows
5. POST /webhooks/generic triggers workflows with JSON payload
6. HMAC signature validation works on generic endpoint
7. Idempotency tracking prevents duplicate executions
8. Results sent back to WhatsApp/Telegram after completion
9. Error messages sent back on workflow failure
10. All tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/03-interfaces-and-triggers/03-03-SUMMARY.md`
</output>
