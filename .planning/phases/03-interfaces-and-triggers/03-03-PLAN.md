---
phase: 03-interfaces-and-triggers
plan: 03
type: execute
wave: 2
depends_on: [01, 02]
files_modified:
  - src/configurable_agents/webhooks/__init__.py
  - src/configurable_agents/webhooks/base.py
  - src/configurable_agents/runtime/executor.py
  - src/configurable_agents/storage/models.py
  - src/configurable_agents/storage/base.py
  - src/configurable_agents/storage/sqlite.py
  - src/configurable_agents/storage/factory.py
  - src/configurable_agents/storage/__init__.py
  - tests/webhooks/test_base.py
  - tests/webhooks/test_router_base.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Generic webhook endpoint accepts POST requests with workflow_name and inputs"
    - "Webhook signatures are verified for security using HMAC validation"
    - "Idempotency keys prevent duplicate workflow executions from replay attacks"
    - "Async workflow execution works from FastAPI background tasks"
  artifacts:
    - path: "src/configurable_agents/webhooks/base.py"
      provides: "Generic webhook handler with HMAC validation"
      exports: ["WebhookHandler", "verify_signature"]
    - path: "src/configurable_agents/runtime/executor.py"
      provides: "run_workflow_async function for webhook triggers"
      exports: ["run_workflow_async"]
    - path: "src/configurable_agents/storage/models.py"
      provides: "WebhookEventRecord for idempotency tracking"
      contains: "class WebhookEventRecord"
    - path: "src/configurable_agents/webhooks/router.py"
      provides: "FastAPI router with generic webhook endpoint"
      exports: ["router as webhooks_router"]
  key_links:
    - from: "src/configurable_agents/webhooks/router.py"
      to: "src/configurable_agents/runtime/executor.py"
      via: "run_workflow_async() for background workflow execution"
      pattern: "run_workflow_async"
    - from: "src/configurable_agents/webhooks/base.py"
      to: "src/configurable_agents/storage"
      via: "WebhookEventRepository for idempotency key tracking"
      pattern: "WebhookEventRepository"
---

<objective>
Build generic webhook infrastructure with HMAC signature validation, idempotency protection, and async workflow execution - the foundation for all webhook integrations.

Purpose: Provide a secure, reusable webhook handler that prevents replay attacks and integrates with the workflow executor. Platform-specific handlers (WhatsApp, Telegram) will be built in plan 03-03B.

Output: Generic webhook endpoint at /webhooks/generic with signature validation, idempotency tracking, and async execution
</objective>

<execution_context>
@C:\Users\ghost\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\ghost\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-interfaces-and-triggers/03-RESEARCH.md
@.planning/phases/01-core-engine/01-04-SUMMARY.md
@.planning/phases/02-agent-infrastructure/02-01A-SUMMARY.md

@src/configurable_agents/runtime/executor.py
@src/configurable_agents/config/schema.py
@src/configurable_agents/storage/models.py
@src/configurable_agents/storage/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook storage and async workflow execution</name>
  <files>src/configurable_agents/storage/models.py, src/configurable_agents/storage/base.py, src/configurable_agents/storage/sqlite.py, src/configurable_agents/storage/factory.py, src/configurable_agents/storage/__init__.py, src/configurable_agents/runtime/executor.py</files>
  <action>
    Add webhook idempotency tracking and async workflow execution:

    1. **Add WebhookEventRecord ORM model to models.py:**
       - __tablename__ = "webhook_events"
       - Fields: id (Integer, autoincrement PK), webhook_id (String(255), unique, indexed), provider (String(64)), processed_at (DateTime, default=datetime.utcnow)
       - Unique constraint on webhook_id prevents duplicate processing

    2. **Add WebhookEventRepository to base.py:**
       - is_processed(webhook_id: str) -> bool: Check if webhook event was already processed
       - mark_processed(webhook_id: str, provider: str) -> None: Record webhook as processed
       - cleanup_old_events(days: int = 7) -> int: Delete records older than N days, return count deleted

    3. **Add SqliteWebhookEventRepository to sqlite.py:**
       - Implement all methods using AsyncSession
       - Use INSERT OR IGNORE for idempotent mark_processed()
       - Follow existing repository patterns from 01-01A-SUMMARY

    4. **Update factory.py and storage/__init__.py:**
       - create_storage_backend() now returns 6-tuple (add webhook_event_repo)
       - Export WebhookEventRepository and SqliteWebhookEventRepository

    5. **Add run_workflow_async() to runtime/executor.py:**
       - async def run_workflow_async(config_path: str, inputs: Dict[str, Any]) -> Dict[str, Any]
       - Wraps existing run_workflow_from_config() in async wrapper using asyncio.to_thread()
       - Enables background task execution from FastAPI endpoints
       - Raises same exceptions as run_workflow() for proper error handling

    Reference research: .planning/phases/03-interfaces-and-triggers/03-RESEARCH.md lines 487-576, 1106-1121
  </action>
  <verify>
    from configurable_agents.storage import WebhookEventRepository, create_storage_backend
    from configurable_agents.runtime.executor import run_workflow_async

    # Test repository
    _, _, _, _, _, webhook_repo = create_storage_backend(None)
    assert not await webhook_repo.is_processed("test-id")
    await webhook_repo.mark_processed("test-id", "test-provider")
    assert await webhook_repo.is_processed("test-id")

    # Test async executor (if test workflow exists)
    # result = await run_workflow_async("tests/fixtures/simple_workflow.yaml", {"input": "test"})
    # assert result is not None
  </verify>
  <done>
    WebhookEventRecord ORM model created
    WebhookEventRepository interface defined and implemented
    create_storage_backend() returns 6-tuple with webhook_event_repo
    run_workflow_async() function works for background execution
    Idempotency tracking prevents duplicate processing
  </done>
</task>

<task type="auto">
  <name>Task 2: Create generic webhook handler with HMAC validation and FastAPI router</name>
  <files>src/configurable_agents/webhooks/__init__.py, src/configurable_agents/webhooks/base.py, src/configurable_agents/webhooks/router.py, tests/webhooks/test_base.py, tests/webhooks/test_router_base.py</files>
  <action>
    Create base webhook handler with security features and FastAPI router:

    1. **Create webhooks package:**
       - src/configurable_agents/webhooks/__init__.py: Exports for WebhookHandler, verify_signature, router

    2. **Create base.py with security utilities:**
       - HMAC signature validation using hmac.compare_digest() for timing-attack safety

       def verify_signature(payload: bytes, signature: str, secret: str, algorithm: str = "sha256") -> bool:
         * Compute expected HMAC hash of payload using secret
         * Remove algorithm prefix if present (e.g., "sha256=")
         * Use hmac.compare_digest() for constant-time comparison
         * Return True if valid, False otherwise

       class WebhookHandler:
         * __init__(secret: str, signature_header: str = "X-Signature", algorithm: str = "sha256")
         * verify_request(request: Request) -> bool: Read body, extract signature, verify
         * async def handle_webhook(self, request: Request, handler_func: Callable, webhook_repo: WebhookEventRepository) -> dict:
           - Verify signature
           - Check for replay attack using webhook_id
           - Parse JSON payload
           - Call handler_func with validated data
           - Return handler response

       class WebhookError(Exception): Base exception for webhook errors
       class InvalidSignatureError(WebhookError): Raised when signature verification fails
       class ReplayAttackError(WebhookError): Raised when webhook_id already processed

    3. **Create router.py with FastAPI endpoints:**
       - from fastapi import APIRouter, Request, BackgroundTasks, HTTPException
       - router = APIRouter(prefix="/webhooks")

       **Generic webhook endpoint:**
       - POST /generic: Accept JSON payload with workflow_name, inputs, optional webhook_id
         * Verify HMAC signature if X-Signature header present
         * Check idempotency via webhook_id
         * Run workflow via run_workflow_async()
         * Return result

       Helper functions:
       - _get_webhook_secret(provider: str) -> str: Get secret from env var (WEBHOOK_SECRET_{PROVIDER} or WEBHOOK_SECRET_DEFAULT)

    4. **Create tests:**
       - test_base.py: Test verify_signature(), WebhookHandler, exception classes
       - test_router_base.py: Test generic webhook endpoint with TestClient, HMAC validation, idempotency

       Use pytest with pytest.mark.asyncio
       Mock storage repositories for idempotency tests
       Use TestClient from fastapi.testclient

    Reference research: .planning/phases/03-interfaces-and-triggers/03-RESEARCH.md lines 487-576, 1347-1475
    Use existing FastAPI test patterns from 02-01A-SUMMARY
  </action>
  <verify>
    pytest tests/webhooks/test_base.py tests/webhooks/test_router_base.py -v
    # All tests pass

    # Test generic webhook manually
    # curl -X POST http://localhost:7862/webhooks/generic \
    #   -H "Content-Type: application/json" \
    #   -d '{"workflow_name":"test","inputs":{"topic":"AI"}}'
  </verify>
  <done>
    verify_signature() function with constant-time comparison
    WebhookHandler class with signature validation
    Replay attack detection via webhook_id
    Generic webhook endpoint at POST /webhooks/generic
    HMAC signature validation on X-Signature header
    Idempotency tracking preventing replay attacks
    All tests passing with >80% coverage
  </done>
</task>

</tasks>

<verification>
After completing all tasks, verify:

1. **Webhook tests pass:**
   ```bash
   pytest tests/webhooks/test_base.py tests/webhooks/test_router_base.py -v
   ```

2. **Import verification:**
   ```bash
   python -c "from configurable_agents.webhooks import WebhookHandler, router; from configurable_agents.runtime.executor import run_workflow_async; print('OK')"
   ```

3. **Generic webhook test:**
   ```bash
   curl -X POST http://localhost:7862/webhooks/generic -H "Content-Type: application/json" -d '{"workflow_name":"test","inputs":{"topic":"AI"}}'
   ```
</verification>

<success_criteria>
1. WebhookEventRecord model exists with webhook_id unique constraint
2. WebhookEventRepository implements is_processed() and mark_processed()
3. verify_signature() uses hmac.compare_digest() for timing safety
4. WebhookHandler validates signatures and checks replay attacks
5. POST /webhooks/generic accepts workflow_name and inputs
6. HMAC validation works when X-Signature header present
7. Idempotency tracking prevents duplicate webhook_id processing
8. run_workflow_async() executes workflows in background tasks
9. All tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/03-interfaces-and-triggers/03-03-SUMMARY.md`
</output>
