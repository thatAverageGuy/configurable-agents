---
phase: 02-agent-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/configurable_agents/storage/models.py
  - src/configurable_agents/storage/sqlite.py
  - src/configurable_agents/storage/base.py
  - src/configurable_agents/deploy/generator.py
  - src/configurable_agents/deploy/templates/Dockerfile.template
  - src/configurable_agents/deploy/templates/server.py.template
  - src/configurable_agents/deploy/templates/requirements.txt.template
  - src/configurable_agents/registry/__init__.py
  - src/configurable_agents/registry/models.py
  - src/configurable_agents/registry/client.py
  - src/configurable_agents/registry/server.py
autonomous: true

must_haves:
  truths:
    - "Agent Docker image is under 100MB with no UI dependencies bundled"
    - "New agent container registers itself on startup and appears in registry"
    - "Registry removes dead agents after TTL expires"
    - "Agent container exposes /health, /health/live, and /health/ready endpoints"
    - "Agents send periodic heartbeats to refresh TTL"
  artifacts:
    - path: "src/configurable_agents/registry/models.py"
      provides: "Agent registry ORM models"
      contains: "class AgentRecord"
      min_lines: 50
    - path: "src/configurable_agents/registry/server.py"
      provides: "Agent registry FastAPI server"
      exports: ["app", "AgentRegistryServer"]
      min_lines: 150
    - path: "src/configurable_agents/registry/client.py"
      provides: "Agent registration client for heartbeat loop"
      exports: ["AgentRegistryClient"]
      min_lines: 100
    - path: "src/configurable_agents/storage/sqlite.py"
      provides: "Agent registry repository implementation"
      contains: "AgentRegistryRepository"
    - path: "src/configurable_agents/deploy/templates/Dockerfile.template"
      provides: "Multi-stage Docker build with health check"
      contains: "HEALTHCHECK"
  key_links:
    - from: "src/configurable_agents/deploy/templates/server.py.template"
      to: "src/configurable_agents/registry/client.py"
      via: "AgentRegistryClient import and usage"
      pattern: "from configurable_agents.registry import AgentRegistryClient"
    - from: "src/configurable_agents/registry/server.py"
      to: "src/configurable_agents/storage/base.py"
      via: "AgentRegistryRepository interface"
      pattern: "class AgentRegistryRepository"
---

<objective>
Implement minimal agent containers with bidirectional self-registration and health monitoring.

**Purpose:** Enable agents to run as lightweight Docker containers (~100MB) that automatically register with a central orchestrator, maintain health via heartbeats, and are auto-removed when they die. This provides the foundation for multi-agent orchestration while keeping containers minimal by decoupling MLFlow UI.

**Output:**
- Agent registry SQLite schema with TTL-based expiration
- FastAPI agent registry server with registration/heartbeat endpoints
- Agent registry client for self-registration and heartbeat background tasks
- Updated deployment templates with registry integration
- Health check endpoints (liveness/readiness) on agent containers
- Multi-stage Dockerfile optimization for <100MB images
</objective>

<execution_context>
@C:\Users\ghost\.claude\get-shit-done/workflows/execute-plan.md
@C:\Users\ghost\.claude\get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-agent-infrastructure/02-RESEARCH.md

# Existing infrastructure from Phase 1
@src/configurable_agents/storage/models.py
@src/configurable_agents/storage/base.py
@src/configurable_agents/storage/sqlite.py
@src/configurable_agents/deploy/generator.py
@src/configurable_agents/deploy/templates/Dockerfile.template
@src/configurable_agents/deploy/templates/server.py.template
@src/configurable_agents/runtime/executor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent registry storage layer</name>
  <files>src/configurable_agents/storage/models.py, src/configurable_agents/storage/base.py, src/configurable_agents/storage/sqlite.py</files>
  <action>
Add agent registry models and repository:

1. **Extend storage/models.py**:
   - Add `AgentRecord` ORM model with fields:
     - agent_id (String(255), primary key)
     - agent_name (String(256))
     - host (String(256))
     - port (Integer)
     - last_heartbeat (DateTime, indexed)
     - ttl_seconds (Integer, default=60)
     - metadata (String(4000), JSON blob)
     - registered_at (DateTime)
   - Add `is_alive()` method that checks: `datetime.utcnow() < last_heartbeat + timedelta(seconds=ttl_seconds)`

2. **Extend storage/base.py**:
   - Add `AgentRegistryRepository(abc.ABC)` abstract interface with methods:
     - `add(agent: AgentRecord) -> None`
     - `get(agent_id: str) -> Optional[AgentRecord]`
     - `list_all(include_dead: bool = False) -> list[AgentRecord]`
     - `update_heartbeat(agent_id: str) -> None`
     - `delete(agent_id: str) -> None`
     - `delete_expired() -> int` (returns count deleted)

3. **Extend storage/sqlite.py**:
   - Implement `AgentRegistryRepository` using aiosqlite for async access
   - Use repository pattern from existing WorkflowRunRepository
   - For `update_heartbeat`: update `last_heartbeat = datetime.utcnow()`
   - For `delete_expired`: DELETE WHERE `datetime.utcnow() > last_heartbeat + ttl_seconds`
   - Create `agents` table in `initialize_db()`

Reference: Phase 1 storage patterns (WorkflowRunRepository), RESEARCH.md Pattern 2 (TTL heartbeat), Pattern 7 (SQLite schema).
  </action>
  <verify>
Run: `python -c "from configurable_agents.storage import create_storage_backend; repo, _ = create_storage_backend(); print('Agent registry repo:', type(repo).__name__)"`

Verify: Check that `AgentRecord` model exists with `is_alive()` method in models.py
  </verify>
  <done>
Agent registry ORM model created with TTL-based expiration check, repository interface defined, SQLite async implementation complete, agents table created on initialization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create agent registry server (FastAPI)</name>
  <files>src/configurable_agents/registry/__init__.py, src/configurable_agents/registry/models.py, src/configurable_agents/registry/server.py</files>
  <action>
Create new registry module with FastAPI server:

1. **Create src/configurable_agents/registry/__init__.py**:
   - Export: AgentRegistryServer, AgentRegistryClient, AgentRecord

2. **Create src/configurable_agents/registry/models.py** (if not in storage):
   - Re-export AgentRecord from storage.models for convenience
   - Add Pydantic request/response models:
     - `AgentRegistrationRequest(agent_id, agent_name, host, port, ttl_seconds, metadata)`
     - `AgentInfo(agent_id, agent_name, host, port, is_alive, last_heartbeat, registered_at)`

3. **Create src/configurable_agents/registry/server.py**:
   - `AgentRegistryServer` class with:
     - `__init__(self, registry_url: str, repo: AgentRegistryRepository)`
     - `create_app() -> FastAPI` - returns FastAPI application
   - FastAPI endpoints:
     - `POST /agents/register` - Agent self-registration (idempotent: update if exists)
     - `POST /agents/{agent_id}/heartbeat` - Refresh TTL
     - `GET /agents` - List all agents (filter dead via `include_dead` query param)
     - `GET /agents/{agent_id}` - Get specific agent info
     - `DELETE /agents/{agent_id}` - Manual deregistration
     - `GET /health` - Registry health check
   - Background cleanup task: Delete expired agents every 60 seconds
   - Use FastAPI's `@app.on_event("startup")` to start cleanup loop via `asyncio.create_task()`

Reference: RESEARCH.md Pattern 3 (FastAPI health endpoints), Pattern 7 (registry endpoints code example).
  </action>
  <verify>
Run: `python -c "from configurable_agents.registry import AgentRegistryServer; print('Registry server imported successfully')"`

Run: `python -c "from fastapi.testclient import TestClient; from configurable_agents.registry import AgentRegistryServer; server = AgentRegistryServer('sqlite:///test.db'); app = server.create_app(); client = TestClient(app); print('Health:', client.get('/health').json())"`
  </verify>
  <done>
AgentRegistryServer created with FastAPI app, registration/heartbeat/list/deregister endpoints implemented, background cleanup task running, health endpoint functional.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create agent registry client (heartbeat loop)</name>
  <files>src/configurable_agents/registry/client.py</files>
  <action>
Create agent registry client for self-registration and heartbeat:

**Create src/configurable_agents/registry/client.py**:

- `AgentRegistryClient` class with:
  - `__init__(self, registry_url: str, agent_id: str, ttl_seconds: int = 60, heartbeat_interval: int = 20)`
    - Store registry_url, agent_id, TTL, heartbeat_interval
    - Create `httpx.AsyncClient()` for HTTP requests
  - `async def register(self, metadata: dict) -> None`:
    - POST to `{registry_url}/agents/register` with payload
    - Payload: agent_id, agent_name (from metadata or agent_id), host (auto-detect or from metadata), port, ttl_seconds, metadata
  - `async def start_heartbeat_loop(self) -> None`:
    - Create background task via `asyncio.create_task(self._heartbeat())`
    - Store task in `self._heartbeat_task`
  - `async def _heartbeat(self) -> None`:
    - Infinite loop: POST to `/agents/{agent_id}/heartbeat`, sleep for `heartbeat_interval`
    - Catch asyncio.CancelledError to exit cleanly
    - On HTTP errors: sleep 5 seconds and retry (don't crash)
  - `async def deregister(self) -> None`:
    - Cancel heartbeat task if running
    - DELETE to `/agents/{agent_id}`

- **Auto-detection helper**: `_get_host_port()` method that:
  - Tries env vars: `AGENT_HOST`, `AGENT_PORT`
  - Falls back to socket.gethostname() and port 8000

Reference: RESEARCH.md Pattern 2 (Agent self-registration with TTL heartbeat code example).
  </action>
  <verify>
Run: `python -c "from configurable_agents.registry import AgentRegistryClient; print('Client imported:', AgentRegistryClient)"`

Run: `python -c "import asyncio; from configurable_agents.registry import AgentRegistryClient; client = AgentRegistryClient('http://localhost:8000', 'test-agent'); print('Client created with TTL:', client.ttl_seconds)"`
  </verify>
  <done>
AgentRegistryClient created with register/start_heartbeat_loop/deregister methods, background heartbeat loop implements retry-on-error, host/port auto-detection from env vars.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update deployment generator for registry integration</name>
  <files>src/configurable_agents/deploy/generator.py, src/configurable_agents/deploy/templates/Dockerfile.template, src/configurable_agents/deploy/templates/server.py.template, src/configurable_agents/deploy/templates/requirements.txt.template</files>
  <action>
Update deployment templates to include agent registry integration:

1. **Update generator.py**:
   - Add `enable_registry: bool = False` parameter to `generate()` method
   - Add `registry_url: str | None = None` parameter
   - Add `agent_id: str | None = None` parameter (default: workflow_name)
   - Pass registry variables to `_build_template_variables()`

2. **Update _build_template_variables() in generator.py**:
   - Add registry-related template variables:
     - `registry_enabled`: boolean
     - `registry_url`: registry endpoint or empty string
     - `agent_id`: agent identifier
     - `heartbeat_interval`: default 20 (TTL/3)

3. **Update Dockerfile.template**:
   - Add httpx to requirements section (registry client needs async HTTP)
   - Ensure HEALTHCHECK remains (already present)

4. **Update server.py.template**:
   - Add conditional import (top of file):
     ```python
     ${registry_import}
     ```
   - Add agent registry initialization (after workflow config load):
     ```python
     ${registry_client_init}
     ```
   - Add startup event to register agent and start heartbeat:
     ```python
     ${registry_startup_handler}
     ```
   - Add shutdown event to deregister:
     ```python
     ${registry_shutdown_handler}
     ```
   - Add /health/live and /health/ready endpoints (RESEARCH.md Pattern 3):
     ```python
     ${health_check_endpoints}
     ```

5. **Update requirements.txt.template**:
   - Add `httpx>=0.26.0` for async HTTP in registry client

6. **Template variable substitution logic**:
   - If `enable_registry=True`: generate code that imports AgentRegistryClient, initializes it, starts heartbeat on startup, stops on shutdown
   - If `enable_registry=False`: generate empty/no-op code blocks

Reference: Existing generator.py patterns, RESEARCH.md Pattern 2 (heartbeat background task), Pattern 3 (health endpoints).
  </action>
  <verify>
Run: `python -c "from configurable_agents.deploy import DeploymentArtifactGenerator; from configurable_agents.config import WorkflowConfig; print('Generator imports OK')"`

Run: Test template generation: Create a dummy config, call `generator.generate(output_dir, enable_registry=True, registry_url='http://localhost:9000')`, verify generated server.py contains registry client code.
  </verify>
  <done>
Deployment generator updated with registry parameters, Dockerfile template includes httpx dependency, server.py template conditionally generates registry client code, health/live/ready endpoints added, template substitution handles enable_registry flag.
  </done>
</task>

<task type="auto">
  <name>Task 5: Create CLI command for standalone registry server</name>
  <files>src/configurable_agents/cli.py</files>
  <action>
Add CLI command to run standalone agent registry server:

**Update cli.py**:

Add new command group `agent-registry` with subcommands:
- `configurable-agents agent-registry start` - Start registry server
- `configurable-agents agent-registry list` - List registered agents
- `configurable-agents agent-registry cleanup` - Manually trigger cleanup

Implementation details:
1. Use Typer for CLI argument parsing (existing pattern)
2. `start` subcommand:
   - Arguments: `--host 0.0.0.0`, `--port 9000`, `--db-url sqlite:///agent_registry.db`
   - Creates AgentRegistryRepository from db_url
   - Creates AgentRegistryServer with repo
   - Runs uvicorn with server's app
3. `list` subcommand:
   - Arguments: `--db-url`, `--include-dead`
   - Queries repo and prints table of agents
4. `cleanup` subcommand:
   - Arguments: `--db-url`
   - Calls repo.delete_expired() and prints count

Reference: Existing CLI patterns in cli.py (run/validate/deploy commands).
  </action>
  <verify>
Run: `python -m configurable_agents agent-registry --help`

Run: `python -m configurable_agents agent-registry start --help`

Run: `python -m configurable_agents agent-registry list --help`
  </verify>
  <done>
CLI command group added for agent-registry with start/list/cleanup subcommands, start command runs uvicorn with FastAPI app, list command displays agent table, cleanup command manually triggers expired agent deletion.
  </done>
</task>

<task type="auto">
  <name>Task 6: Add registry integration tests</name>
  <files>tests/core/test_parallel.py, tests/registry/test_client.py, tests/registry/test_server.py</files>
  <action>
Create tests for agent registry functionality:

1. **Create tests/registry/__init__.py**

2. **Create tests/registry/test_client.py**:
   - Test AgentRegistryClient initialization
   - Test register() method (mock HTTP response)
   - Test heartbeat loop (test cancellation, error retry)
   - Test deregister() method

3. **Create tests/registry/test_server.py**:
   - Test POST /agents/register creates new agent
   - Test POST /agents/register updates existing agent (idempotent)
   - Test POST /agents/{id}/heartbeat updates timestamp
   - Test GET /agents lists agents, filters dead when include_dead=False
   - Test DELETE /agents/{id} removes agent
   - Test background cleanup task removes expired agents

4. **Create tests/registry/test_ttl_expiry.py**:
   - Test AgentRecord.is_alive() with various timestamps
   - Test delete_expired() removes only expired agents
   - Test edge cases (TTL=0, negative TTL, etc.)

Use pytest with httpx.TestClient for server tests, unittest.mock for client HTTP tests.

Reference: Existing test patterns in tests/core/test_parallel.py.
  </action>
  <verify>
Run: `pytest tests/registry/ -v`

Run: `pytest tests/registry/test_client.py -k "test_register" -v`

Run: `pytest tests/registry/test_server.py -k "test_heartbeat" -v`
  </verify>
  <done>
Registry test suite created with client/server/model tests, all tests pass, coverage >80% for registry module.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Image Size Verification**:
   - Generate deployment artifacts with `enable_registry=True`
   - Build Docker image: `docker build -t test-agent .`
   - Check image size: `docker images test-agent` - should be < 100MB (excluding MLFlow UI, ~200MB with MLFlow)

2. **Registration Verification**:
   - Start registry server: `python -m configurable_agents agent-registry start --port 9000`
   - In another terminal, deploy agent with registry enabled
   - Call registry's GET /agents - verify agent appears in list
   - Check agent's `last_heartbeat` and `is_alive` status

3. **TTL Expiry Verification**:
   - Stop agent container (simulate crash)
   - Wait 70 seconds (60s TTL + buffer)
   - Call GET /agents on registry - verify agent is removed or marked dead

4. **Health Endpoint Verification**:
   - Call agent's /health - returns `{"status": "healthy"}`
   - Call agent's /health/live - returns `{"status": "alive"}`
   - Call agent's /health/ready - returns `{"status": "ready"}` (or 503 if dependencies not met)

5. **CLI Verification**:
   - `python -m configurable_agents agent-registry list` - displays agent table
   - `python -m configurable_agents agent-registry cleanup` - reports expired count
</verification>

<success_criteria>
**Phase Success Criteria Met:**
1. Agent Docker image is under 100MB without MLFlow UI bundled (verified via `docker images`)
2. New agent container registers on startup and appears in registry within 5 seconds (verified via GET /agents)
3. Registry removes dead agents after TTL expires (verified by stopping container and waiting)
4. Agent container exposes /health, /health/live, /health/ready endpoints (verified via curl/httpx)
5. Heartbeat loop runs in background without blocking FastAPI event loop (verified by agent remaining responsive)
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-infrastructure/02-01-SUMMARY.md` with:
- Frontmatter (phase, plan, wave, status, completed_at, tech_added, patterns_established, key_files)
- Summary of changes (storage layer, registry server/client, deployment updates)
- Verification results (image size, registration flow, TTL expiry, health endpoints)
- Next steps link (02-02: Production observability)
</output>
