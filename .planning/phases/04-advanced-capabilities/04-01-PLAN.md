---
phase: 04-advanced-capabilities
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/configurable_agents/config/schema.py
  - src/configurable_agents/sandbox/__init__.py
  - src/configurable_agents/sandbox/python_executor.py
  - src/configurable_agents/sandbox/docker_executor.py
  - src/configurable_agents/sandbox/base.py
  - src/configurable_agents/core/node_executor.py
  - pyproject.toml
  - tests/sandbox/test_python_executor.py
  - tests/sandbox/test_docker_executor.py
autonomous: true
user_setup:
  - service: docker
    why: "Docker-based code sandbox isolation (opt-in)"
    env_vars:
      - name: DOCKER_HOST
        source: "Docker Desktop settings or daemon config (default: unix:///var/run/docker.sock on Unix, npipe:////./pipe/docker_engine on Windows)"
    dashboard_config:
      - task: "Verify Docker daemon is running"
        location: "Run 'docker ps' - should return list of containers"

must_haves:
  truths:
    - "User can execute Python code in a RestrictedPython sandbox without Docker"
    - "User can execute Python code in a Docker container with resource limits when use_docker: true"
    - "User can configure resource presets (Low/Medium/High/Max) at workflow or node level"
    - "User can disable network access via network: false in sandbox config"
    - "Sandbox execution errors are caught and returned as node results"
  artifacts:
    - path: "src/configurable_agents/sandbox/python_executor.py"
      provides: "RestrictedPython-based code execution"
      exports: ["PythonSandboxExecutor", "execute_code"]
      min_lines: 100
    - path: "src/configurable_agents/sandbox/docker_executor.py"
      provides: "Docker-based code execution with resource limits"
      exports: ["DockerSandboxExecutor", "execute_in_container"]
      min_lines: 150
    - path: "src/configurable_agents/sandbox/base.py"
      provides: "Abstract sandbox executor interface"
      exports: ["SandboxExecutor", "SandboxResult"]
      min_lines: 50
    - path: "src/configurable_agents/config/schema.py"
      provides: "Extended NodeConfig with sandbox configuration"
      contains: "SandboxConfig"
  key_links:
    - from: "src/configurable_agents/core/node_executor.py"
      to: "src/configurable_agents/sandbox"
      via: "Import and instantiate sandbox executor based on node.sandbox config"
      pattern: "from configurable_agents.sandbox import.*SandboxExecutor"
    - from: "src/configurable_agents/sandbox/docker_executor.py"
      to: "docker"
      via: "docker-py library for container management"
      pattern: "import docker"
---

<objective>
Implement safe code execution for agent-generated Python code using RestrictedPython by default with optional Docker isolation for production use cases.

Purpose: Enable agents to execute dynamically generated Python code safely, with portability for local development (RestrictedPython) and isolation for production (Docker). This satisfies RT-04 requirement for sandboxed code execution.

Output: Two-mode sandbox system (RestrictedPython + Docker) with configurable resource limits, network controls, and graceful error handling.
</objective>

<execution_context>
@C:\Users\ghost\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ghost\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-advanced-capabilities/04-CONTEXT.md
@src/configurable_agents/core/node_executor.py
@src/configurable_agents/config/schema.py
@src/configurable_agents/storage/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sandbox executor base interface and RestrictedPython implementation</name>
  <files>
    src/configurable_agents/sandbox/__init__.py
    src/configurable_agents/sandbox/base.py
    src/configurable_agents/sandbox/python_executor.py
    tests/sandbox/__init__.py
    tests/sandbox/test_python_executor.py
  </files>
  <action>
    Create sandbox executor module with:

    1. **src/configurable_agents/sandbox/base.py** - Abstract interface:
       - `SandboxResult` dataclass: success (bool), output (Any), error (str|None), execution_time (float)
       - `SandboxExecutor` abstract base class with:
         - `execute(code: str, inputs: dict, timeout: int) -> SandboxResult`
         - `_validate_code(code: str) -> None` (raise if unsafe)
       - Define SafetyError exception class for security violations

    2. **src/configurable_agents/sandbox/python_executor.py** - RestrictedPython implementation:
       - Install RestrictedPython via pyproject.toml (add `restrictedpython>=6.0`)
       - `PythonSandboxExecutor` class implementing SandboxExecutor:
         - Use `RestrictionNode` and `compile_restricted()` for AST-based code compilation
         - Allow safe builtins: dict, list, str, int, float, bool, len, range, enumerate, zip, sum, min, max, print
         - Block unsafe operations: imports (except safe list), file I/O, subprocess, eval, exec, getattr, setattr, delattr, __import__
         - Create isolated globals dict for execution with safe builtins only
         - Execute compiled code with `exec()` using timeout via `signal.alarm()` or `func_timeout` library
         - Capture stdout/stderr using io.StringIO
         - Extract return value from special variable `__result` (document this convention)
         - Return SandboxResult with captured output or error
       - Handle exceptions: SyntaxError, SecurityError, TimeoutError, RuntimeError

    3. **src/configurable_agents/sandbox/__init__.py** - Public API:
       - Export `SandboxExecutor`, `SandboxResult`, `PythonSandboxExecutor`, `SafetyError`

    4. **tests/sandbox/test_python_executor.py** - Test suite (min 200 lines):
       - Test safe code execution (arithmetic, string operations, list comprehensions)
       - Test blocked unsafe operations (imports, file access, subprocess)
       - Test timeout enforcement
       - Test return value extraction via `__result`
       - Test stdout/stderr capture
       - Test error handling and SandboxResult structure
       - Use pytest.raises for exception testing

    Follow project conventions:
    - Use logging.getLogger(__name__) for logger
    - Type annotate all functions (mypy strict mode)
    - Google-style docstrings
  </action>
  <verify>
    Run tests: pytest tests/sandbox/test_python_executor.py -v
    Verify RestrictedPython is added: grep restrictedpython pyproject.toml
  </verify>
  <done>
    PythonSandboxExecutor safely executes code, blocks unsafe operations, enforces timeout, and returns structured results. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Docker sandbox executor with resource limits</name>
  <files>
    src/configurable_agents/sandbox/docker_executor.py
    tests/sandbox/test_docker_executor.py
    pyproject.toml
  </files>
  <action>
    Create Docker-based sandbox executor:

    1. **pyproject.toml** - Add docker dependency:
       - Add `docker>=7.0.0` to dependencies

    2. **src/configurable_agents/sandbox/docker_executor.py** - Docker implementation:
       - `DockerSandboxExecutor` class implementing SandboxExecutor:
         - Accept `image_name` (default: "python:3.11-slim") in constructor
         - `execute(code: str, inputs: dict, timeout: int, resources: dict) -> SandboxResult`:
           - Create temporary directory for code/input/output files
           - Write code to temp file with input dict embedded as `inputs = {...}` variable
           - Configure docker container:
             - Resource limits from resources dict: cpu_quota, mem_limit, cpu_shares
             - Network mode: "none" if network=False else "default"
             - Read-only root filesystem
             - No privileged mode
             - Remove container on exit (--rm equivalent)
           - Mount temp directory as volume
           - Execute python with timeout
           - Capture stdout/stderr from container logs
           - Read output from temp file
           - Clean up temp directory
         - Handle Docker errors gracefully (daemon not running, image pull fails, container crash)
         - Return SandboxResult with output or error

    3. **Resource preset constants** (define at module level):
       - `RESOURCE_PRESETS` dict:
         - "low": {"cpu": 0.5, "memory": "256m", "timeout": 30}
         - "medium": {"cpu": 1.0, "memory": "512m", "timeout": 60}
         - "high": {"cpu": 2.0, "memory": "1g", "timeout": 120}
         - "max": {"cpu": 4.0, "memory": "2g", "timeout": 300}
       - `get_preset(name: str) -> dict` helper with fallback to "medium"

    4. **tests/sandbox/test_docker_executor.py** - Test suite (min 150 lines):
       - Skip tests if Docker not available (use pytest.mark.skipif with docker.from_env check)
       - Test basic code execution in container
       - Test resource limit enforcement (timeout, memory - kill container if exceeded)
       - Test network isolation (network: false blocks HTTP requests)
       - Test error handling (syntax errors, runtime errors)
       - Test custom image support
       - Mark integration tests with @pytest.mark.integration

    5. **Update src/configurable_agents/sandbox/__init__.py**:
       - Export `DockerSandboxExecutor`, `RESOURCE_PRESETS`, `get_preset`

    Follow project conventions:
    - Graceful degradation: if Docker unavailable, return helpful error message
    - All docker operations wrapped in try/except
    - Clean up temp files in finally blocks
  </action>
  <verify>
    Run tests: pytest tests/sandbox/test_docker_executor.py -v
    Verify docker dependency added: grep docker pyproject.toml
    Optional: Manual test with Docker running - execute code in container
  </verify>
  <done>
    DockerSandboxExecutor executes code in isolated containers with configurable resource limits, network controls, and graceful error handling. All tests pass (or skipped if Docker unavailable).
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate sandbox executors into node executor and config schema</name>
  <files>
    src/configurable_agents/config/schema.py
    src/configurable_agents/core/node_executor.py
    tests/sandbox/test_integration.py
    examples/sandbox_example.yaml
  </files>
  <action>
    Integrate sandbox execution into workflow system:

    1. **src/configurable_agents/config/schema.py** - Extend schema:
       - Add `SandboxConfig` Pydantic model:
         - `mode: Literal["python", "docker"] = "python"` (default: RestrictedPython)
         - `enabled: bool = True` (allow disabling sandbox for non-code nodes)
         - `use_docker: bool = False` (workflow-level default override)
         - `network: bool | dict = True` (network access control)
         - `resources: dict | None = None` (resource preset or custom)
         - `preset: Literal["low", "medium", "high", "max"] = "medium"`
       - Add `sandbox: SandboxConfig | None = None` field to `NodeConfig`
       - Add `SandboxConfig` model validator to merge workflow-level defaults with node overrides

    2. **src/configurable_agents/core/node_executor.py** - Wire up sandbox execution:
       - Import sandbox executors: `from configurable_agents.sandbox import PythonSandboxExecutor, DockerSandboxExecutor, get_preset`
       - Add `code_execution` node type handling in execute_node:
         - Check if `node_config.sandbox` is present and `enabled=True`
         - If `node_config.code` (new field) contains Python code:
           - Instantiate executor: `DockerSandboxExecutor()` if `use_docker=True` else `PythonSandboxExecutor()`
           - Resolve resource preset: `get_preset(node_config.sandbox.preset)` merged with `node_config.sandbox.resources`
           - Call `executor.execute(code, inputs, timeout, resources)`
           - Return `SandboxResult.output` as node result, or error result if `success=False`
       - Handle sandbox errors: catch SafetyError and return error node result
       - Add debug logging for sandbox mode selection and execution

    3. **tests/sandbox/test_integration.py** - Integration tests (min 100 lines):
       - Test node execution with Python sandbox (no Docker required)
       - Test code execution node type in workflow config
       - Test sandbox config merging (workflow default, node override)
       - Test error propagation from sandbox to node result
       - Test workflow with code node + LLM node combined

    4. **examples/sandbox_example.yaml** - Example workflow:
       - Document sandbox configuration options
       - Show code execution node with Python sandbox
       - Show Docker sandbox with resource preset
       - Show network isolation example
       - Include README section explaining safety model

    Follow existing patterns:
    - Match existing node error handling pattern
    - Use existing template resolver for inputs
    - Log execution mode at INFO level
  </action>
  <verify>
    Run integration tests: pytest tests/sandbox/test_integration.py -v
    Validate example config: python -m configurable_agents validate examples/sandbox_example.yaml
  </verify>
  <done>
    Node executor executes Python code via sandbox based on node.sandbox config. Users can specify mode, resource presets, and network controls in YAML. Integration tests pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **RestrictedPython mode works without Docker:**
   - Run `python -m configurable_agents run examples/sandbox_example.yaml` with Python sandbox
   - Code executes safely without Docker installed

2. **Docker mode works when available:**
   - Set `use_docker: true` in config
   - Code executes in container with resource limits
   - Network isolation blocks external requests when `network: false`

3. **Error handling:**
   - Unsafe code is rejected with clear error message
   - Runtime errors are caught and returned as node results
   - Timeout enforcement prevents runaway code

4. **All tests pass:**
   - `pytest tests/sandbox/ -v`
   - Coverage >80% for new code
</verification>

<success_criteria>
Phase 4 Plan 01 complete when:
1. RestrictedPython executor safely executes code with timeout and safe builtins
2. Docker executor runs code in isolated containers with resource limits
3. Node executor integrates sandbox based on YAML config
4. Example workflow demonstrates sandbox usage
5. All tests pass (test suite >450 lines total)
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-capabilities/04-01-SUMMARY.md` with:
- Phase/plan metadata header
- Duration and completion date
- Tasks accomplished and commits
- Files created/modified
- Deviations from plan (if any)
- Verification results
</output>
